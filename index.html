<!DOCTYPE html>
<html lang="en" class="dark">
  <head>
    <meta charset="UTF-8" />
    <title>EverStrong</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover"/>
    <!-- Tailwind + React + Babel -->
    <script src="https://cdn.tailwindcss.com"></script>
    <script>tailwind.config={darkMode:'class'}</script>
    <script src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <style>
      :root { color-scheme: light dark; }
      body { -webkit-font-smoothing: antialiased; -webkit-tap-highlight-color: transparent; }
      .card { border:1px solid rgba(255,255,255,.12); border-radius: .9rem; }
      .btn { border-radius: .9rem; padding:.75rem 1rem; }
      .btn-sm { border-radius:.7rem; padding:.5rem .75rem; font-size:.9rem; }
      .safe { padding-left: max(1rem, env(safe-area-inset-left)); padding-right: max(1rem, env(safe-area-inset-right)); }
      a.link { text-decoration: underline; }
    </style>
  </head>
  <body class="bg-gray-100 dark:bg-gray-900 dark:text-gray-100 min-h-screen">
    <div id="root" class="safe py-3"></div>

    <script type="text/babel" data-presets="react">
      const { useState, useEffect, useRef, useMemo } = React;

      /* ========== utils ========== */
      function lsGet(k, f){ try{ const v=localStorage.getItem(k); return v? JSON.parse(v): f; } catch(e){ return f; } }
      function lsSet(k, v){ localStorage.setItem(k, JSON.stringify(v)); }
      function fmtHMS(secs){
        const s=Math.max(0,Math.floor(secs));
        const hh=('0'+Math.floor(s/3600)).slice(-2);
        const mm=('0'+Math.floor((s%3600)/60)).slice(-2);
        const ss=('0'+(s%60)).slice(-2);
        return `${hh}:${mm}:${ss}`;
      }
      function todayStr(){ return new Date().toDateString(); }
      function getLatestMainModalityFromHistory(){
        const keys = ["history:kettlebell","history:barbell","history:bodyweight"];
        let best = null, bestDate = 0;
        keys.forEach(k=>{
          const arr = lsGet(k,[]);
          if (!Array.isArray(arr) || arr.length===0) return;
          const last = arr.reduce((a,b)=> new Date(a.saved_at)>new Date(b.saved_at)?a:b);
          const t = new Date(last.saved_at).getTime();
          if (t > bestDate) { bestDate = t; best = k.split(":")[1]; }
        });
        return best;
      }

      /* ========== training engines ========== */
      function createEngine({ key, patterns, cycleVolumes, sessionsPerCycle=18 }) {
        const saved = lsGet(key, null);
        const eng = {
          key, patterns, cycleVolumes, sessionsPerCycle,
          session_count: (saved && saved.session_count) || 0,
          current_phase: (saved && saved.current_phase) || 1,
          display_cycle_index: (saved && saved.display_cycle_index) || 1,
          exercise_usage_count: (saved && saved.exercise_usage_count) || {},
          last_session_exercises: (saved && saved.last_session_exercises) || [],
          last_session_volumes: (saved && saved.last_session_volumes) || {},
          all_sessions: (saved && saved.all_sessions) || [],

          calculate_volume(exercise, volume_type){
            return this.cycleVolumes[this.current_phase][volume_type];
          },
          get_ladder_pattern(exercise, volume){
            const c=this.current_phase;
            if (c===1){ if(volume===10)return["1-2-3-4",10]; if(volume===20)return["2x 1-2-3-4",20]; if(volume===30)return["3x 1-2-3-4",30]; }
            if (c===2){ if(volume===15)return["1-2-3-4-5",15]; if(volume===25)return["1-2-3-4-5 + 1-2-3-4",25]; if(volume===40)return["2x 1-2-3-4-5 + 1-2-3-4",40]; }
            if (c===3){ if(volume===20)return["2x 1-2-3-4",20]; if(volume===30)return["2x 1-2-3-4-5",30]; if(volume===50)return["3x 1-2-3-4-5 + 1-2",50]; }
            return [String(volume)+" reps", volume];
          },
          get_volume_format(exercise, volume){
            const [ladder,total]=this.get_ladder_pattern(exercise,volume);
            return ladder===`${total} reps` ? `${total} reps` : `${total} reps (${ladder})`;
          },
          select_exercise_for_pattern(pattern){
            const list=this.patterns[pattern].slice();
            const pool=list.filter(ex=>this.last_session_exercises.indexOf(ex)===-1);
            const candidates=pool.length?pool:list;
            const useCount=(ex)=>this.exercise_usage_count[ex]||0;
            let minUse=useCount(candidates[0]);
            for(let i=1;i<candidates.length;i++){ const u=useCount(candidates[i]); if(u<minUse)minUse=u; }
            const least=candidates.filter(ex=> (this.exercise_usage_count[ex]||0)===minUse );
            return least[Math.floor(Math.random()*least.length)];
          },
          select_volume_type(pattern, exercise, current_session_volumes){
            const vals=[]; for(const k in current_session_volumes){ vals.push(current_session_volumes[k]); }
            const highAlready = vals.indexOf('high')>-1;
            const entries = this.all_sessions.filter(s => s.phase===this.current_phase && s.exercise===exercise);
            let lowC=0, medC=0, highC=0;
            for(let i=0;i<entries.length;i++){
              const vt=entries[i].volume_type;
              if(vt==='low')lowC++; else if(vt==='medium')medC++; else if(vt==='high')highC++;
            }
            const valid=[];
            if(medC<3) valid.push('medium');
            if(lowC<2) valid.push('low');
            if(highC<1 && !highAlready) valid.push('high');
            const avoid=this.last_session_volumes ? this.last_session_volumes[pattern] : null;
            let choices = valid.length ? valid : (highAlready ? ['low','medium'] : ['low','medium','high']);
            if(avoid && choices.length>1) choices = choices.filter(t=>t!==avoid);
            return choices[Math.floor(Math.random()*choices.length)];
          },
          generate_single_session(){
            const session_number=(this.session_count%this.sessionsPerCycle)+1;
            const session_exercises=[]; const current_session_volumes={};
            const pattern_order=Object.keys(this.patterns).sort(()=>Math.random()-0.5);

            for(const pattern of pattern_order){
              const exercise=this.select_exercise_for_pattern(pattern);
              const volume_type=this.select_volume_type(pattern,exercise,current_session_volumes);
              const volume=this.calculate_volume(exercise,volume_type);
              const formatted_volume=this.get_volume_format(exercise,volume);
              session_exercises.push({
                session:session_number, pattern, exercise, volume_type, volume,
                formatted_volume, order:session_exercises.length+1, phase:this.current_phase, display_cycle:this.display_cycle_index
              });
              this.exercise_usage_count[exercise]=(this.exercise_usage_count[exercise]||0)+1;
              current_session_volumes[pattern]=volume_type;
            }

            this.last_session_exercises=session_exercises.map(r=>r.exercise);
            this.last_session_volumes=current_session_volumes;
            Array.prototype.push.apply(this.all_sessions, session_exercises);
            this.session_count+=1;

            const main=session_exercises.map(b=>`${b.pattern.replace(/ (Pattern|Category)$/,'')}: ${b.exercise} — ${b.formatted_volume}`);
            this.persist();
            return { main, meta:{ modality:null, cycle:this.display_cycle_index, phase:this.current_phase, session:session_number, phase_end:(session_number===this.sessionsPerCycle) } };
          },
          persist(){
            lsSet(this.key,{
              session_count:this.session_count, current_phase:this.current_phase,
              display_cycle_index:this.display_cycle_index, exercise_usage_count:this.exercise_usage_count,
              last_session_exercises:this.last_session_exercises, last_session_volumes:this.last_session_volumes,
              all_sessions:this.all_sessions
            });
          },
          hardResetToStart(){
            this.display_cycle_index=1; this.current_phase=1; this.session_count=0;
            this.exercise_usage_count={}; this.last_session_exercises=[]; this.last_session_volumes={}; this.all_sessions=[];
            this.persist();
          }
        };
        return eng;
      }

      /* ========== define engines ========== */
      const SFG = createEngine({
        key:'everstrong:sfg:v1',
        patterns:{
          "Swing Pattern":["One-arm Swing","Two-arm Swing","Double Swing"],
          "Get Up Pattern":["Get Up","Windmill","Bent Press"],
          "Clean Pattern":["Single Dead Clean","Double Clean","One-arm Row"],
          "Squat Pattern":["Goblet Squat","Single Front Squat","Double Front Squat"],
          "Press Pattern":["Military Press","Half Kneeling Press","Floor Press"],
          "Snatch Pattern":["Snatch","Low Pull Snatch","High Pull"],
          "Hybrid Pattern":["Double Clean & Press","Double Clean & Front Squat","Double Clean & Jerk"]
        },
        cycleVolumes:{1:{low:10,medium:20,high:30},2:{low:15,medium:25,high:40},3:{low:20,medium:30,high:50}},
        sessionsPerCycle:36
      });
      const SFL = createEngine({
        key:'everstrong:sfl:v1',
        patterns:{
          "Leg Pattern":["Back Squat","Front Squat","Zercher Squat"],
          "Push Pattern":["Bench Press","Incline Bench Press","Shoulder Press"],
          "Pull Pattern":["Conventional Deadlift","Goodmorning","Sumo Deadlift"]
        },
        cycleVolumes:{1:{low:10,medium:20,high:30},2:{low:15,medium:25,high:40},3:{low:20,medium:30,high:50}},
        sessionsPerCycle:18
      });
      const SFB = createEngine({
        key:'everstrong:sfb:v1',
        patterns:{
          "Leg Category":["Box Pistol","Top Down Pistol","Full Pistol"],
          "Push Category":["One-arm One-leg Push Up","Wall HSPU (assist)","Dips"],
          "Pull Category":["Tactical Pull Up","Hanging Leg Raise","Front Lever (prog)"]
        },
        cycleVolumes:{1:{low:10,medium:20,high:30},2:{low:15,medium:25,high:40},3:{low:20,medium:30,high:50}},
        sessionsPerCycle:18
      });

      /* ========== Inferno (300/400/500 SU) ========== */
      (function(){
        const db = {
          squat: [
            { name:"Goblet Squat", stim:1.3, uni:false },
            { name:"Bulgarian Split Squat", stim:1.5, uni:true },
            { name:"Cossack", stim:1.5, uni:true }
          ],
          hinge: [
            { name:"Two-arm Swing", stim:1.1, uni:false },
            { name:"One-arm Swing", stim:1.2, uni:true },
            { name:"Deadlift (KB)", stim:0.9, uni:false }
          ],
          push: [
            { name:"Floor Press", stim:1.2, uni:true },
            { name:"Military Press", stim:1.6, uni:true },
            { name:"Push Press", stim:1.3, uni:true }
          ],
          pull: [
            { name:"Bent-over Row", stim:1.4, uni:true },
            { name:"High Pull", stim:1.4, uni:true },
            { name:"Clean", stim:1.4, uni:true }
          ],
          core: [
            { name:"Russian Twist", stim:0.7, uni:false },
            { name:"Turkish Get-up", stim:3.5, uni:true },
            { name:"Windmill", stim:1.8, uni:true }
          ],
          hybrid: [
            { name:"Clean & Press", stim:2.0, uni:true },
            { name:"Clean → Press → Squat", stim:2.5, uni:true },
            { name:"Snatch & Press", stim:2.0, uni:true }
          ]
        };
        function r(min,max){ return Math.floor(Math.random()*(max-min+1))+min; }
        function pick(a){ return a[Math.floor(Math.random()*(a.length))]; }
        function shuffle(a){ const x=a.slice(); for(let i=x.length-1;i>0;i--){ const j=Math.floor(Math.random()*(i+1)); [x[i],x[j]]=[x[j],x[i]]; } return x; }
        function fmt(ex, su){
          const reps = Math.round(su / ex.stim);
          return `${ex.name} — ${ex.uni?`${reps} reps (${Math.ceil(reps/2)} per arm)`:`${reps} reps`} (${su} SU)`;
        }
        function build(targetSU){
          const pats=Object.keys(db);
          const maxPer=2; let cur=0; const used=Object.fromEntries(pats.map(p=>[p,0])); const out=[];
          for(const p of pats){
            const ex=pick(db[p]); const su=r(30,70); cur+=su; used[p]+=1; out.push(fmt(ex,su));
          }
          let guard=0;
          while(cur<targetSU-30 && guard<1000){
            guard++; const p=pick(pats); if(used[p]>=maxPer) continue;
            const ex=pick(db[p]); const su=r(30,70); if(cur+su>targetSU+10) break;
            cur+=su; used[p]+=1; out.push(fmt(ex,su));
          }
          return shuffle(out);
        }
        window.HELLFIRE_GENERATE = function(target){
          const allowed=[300,400,500];
          if(allowed.indexOf(target)===-1){ target = allowed.reduce((b,c)=>Math.abs(c-target)<Math.abs(b-target)?c:b,allowed[0]); }
          return { lines: build(target), su: target };
        };
      })();

      /* ========== Flow Generator (Active Recovery B) ========== */
      (function(){
        const blocks = {
          prep: ["Rockback → Head Nod","Quadruped Hip Circle","Prone Swimmer","Supine Segmental Roll"],
          seated: ["Seated S Switch","Seated Egyptian","Seated Figure 8 Arms"],
          halfkneel: ["Half-kneeling Windmill Reach","Half-kneeling Halo","Half-kneeling Hip Opener"],
          tallkneel: ["Tall-kneeling Bow & Arrow","Tall-kneeling Side Sit → Tall Kneel"],
          ground: ["Beast Shoulder Tap","Beast to Crab Roll","Crawl → Crab"],
          transitions: ["Side Sit → Shin Box Switch","Pike → Tabletop → Crab","Crawl → Crab → Sit-through"]
        };
        function pick(a){ return a[Math.floor(Math.random()*a.length)]; }
        window.GFM_FLOW_GENERATE = function(){
          const seq = [
            pick(blocks.prep), pick(blocks.seated),
            pick(blocks.halfkneel), pick(blocks.tallkneel),
            pick(blocks.ground), pick(blocks.transitions),
            pick(blocks.seated), pick(blocks.ground),
            pick(blocks.transitions), pick(blocks.prep),
          ];
          return seq.map((line,i)=>`${i+1}. ${line}`);
        };
      })();

      /* ========== Breathing (Full Rest) ========== */
      const BREATH_PROTOCOLS = {
        bottom: { key:'bottom', name:'Bottom Triangle (4–6)', best:'Relax / Recovery',
          phases:[{label:'Inhale',secs:4},{label:'Exhale',secs:6}], summary:'Calms the nervous system, lowers HR, relaxation' },
        box: { key:'box', name:'Box (4–4–4–4)', best:'Focus / Balance',
          phases:[{label:'Inhale',secs:4},{label:'Hold',secs:4},{label:'Exhale',secs:4},{label:'Hold',secs:4}], summary:'Balance and focus, stress regulation' },
        tactical: { key:'tactical', name:'Tactical (4–7–8)', best:'Sleep / Deep Relax',
          phases:[{label:'Inhale',secs:4},{label:'Hold',secs:7},{label:'Exhale',secs:8}], summary:'Deep relaxation, supports sleep' }
      };

      function BreathTimer({ protocolKey, minutes, onDone }) {
        const proto = BREATH_PROTOCOLS[protocolKey];
        const [running,setRunning]=useState(true);
        const [elapsed,setElapsed]=useState(0);
        const total = Math.max(1, minutes)*60;
        const [phaseIndex,setPhaseIndex]=useState(0);
        const [phaseRemaining,setPhaseRemaining]=useState(proto.phases[0].secs);
        const intervalRef=useRef(null);

        useEffect(()=>{
          if(!running) return;
          intervalRef.current = setInterval(()=>{
            setElapsed(e=>e+1);
            setPhaseRemaining(p=>{
              if(p>1) return p-1;
              setPhaseIndex(i=> (i+1)%proto.phases.length );
              return proto.phases[(phaseIndex+1)%proto.phases.length].secs;
            });
          },1000);
          return ()=>{ if(intervalRef.current){ clearInterval(intervalRef.current); intervalRef.current=null; } };
        },[running, phaseIndex, protocolKey]);

        useEffect(()=>{
          if(elapsed>=total){
            setRunning(false);
            if(intervalRef.current){ clearInterval(intervalRef.current); intervalRef.current=null; }
            onDone && onDone();
          }
        },[elapsed,total,onDone]);

        function reset(){
          setRunning(false);
          setElapsed(0);
          setPhaseIndex(0);
          setPhaseRemaining(proto.phases[0].secs);
        }

        const currentPhase = proto.phases[phaseIndex];
        const remainingTotal = Math.max(0,total - elapsed);

        return (
          <div className="p-4 card mt-3">
            <p className="font-semibold text-lg">{proto.name} • {minutes} min</p>
            <p className="text-sm text-gray-400">{proto.summary} — Best for: {proto.best}</p>
            <div className="mt-4 flex items-center justify-between">
              <div>
                <div className="text-2xl font-mono">{currentPhase.label}</div>
                <div className="text-3xl font-mono">{('0'+phaseRemaining).slice(-2)}s</div>
              </div>
              <div className="text-right">
                <div className="text-xs text-gray-400">Total remaining</div>
                <div className="text-2xl font-mono">{fmtHMS(remainingTotal)}</div>
              </div>
            </div>
            <div className="w-full h-2 bg-gray-700 rounded mt-4 overflow-hidden">
              <div className="h-2 bg-blue-500" style={{ width: `${100*(elapsed/total)}%` }} />
            </div>
            <div className="flex gap-2 mt-4">
              {!running
                ? <button onClick={()=>setRunning(true)} className="btn bg-green-600 w-full">Start</button>
                : <button onClick={()=>setRunning(false)} className="btn bg-yellow-500 text-black w-full">Pause</button>}
              <button onClick={reset} className="btn bg-gray-600 w-full">Reset</button>
              <button onClick={()=>{ setRunning(false); onDone && onDone(); }} className="btn bg-blue-600 w-full">Finish</button>
            </div>
          </div>
        );
      }

      /* ========== Smart list renderer (no stray hyphens; clean blank lines) ========== */
      function renderSmartList(lines){
        const out=[]; let buffer=[];
        function flushList(){
          if(buffer.length){
            out.push(
              <ul className="list-disc ml-6 space-y-1" key={"ul-"+out.length}>
                {buffer.map((t,i)=>(<li key={i}>{t}</li>))}
              </ul>
            );
            buffer=[];
          }
        }
        lines.forEach((raw, idx)=>{
          const line = (raw==null) ? "" : String(raw);
          if(line.trim()===""){
            flushList();
            out.push(<div key={"sp-"+idx} className="h-2" />);
            return;
          }
          if(line.startsWith("* ")){
            buffer.push(line.slice(2));
          } else {
            flushList();
            out.push(<p key={"p-"+idx} className="font-medium mt-3">{line}</p>);
          }
        });
        flushList();
        return out;
      }

      /* ========== UI bits ========== */
      function Header({ onHiit, onToggleDark, onRestart, recoveryMode, setRecoveryMode }) {
        return (
          <header className="text-center mb-4">
            <h1 className="text-3xl md:text-4xl font-bold">EverStrong</h1>
            <p className="text-gray-500 dark:text-gray-400 text-sm md:text-base">Longevity-first Strength & Conditioning</p>
            <div className="flex justify-between mt-3 gap-2">
              <div className="flex items-center gap-3">
                <button onClick={onToggleDark} className="text-sm text-purple-400 underline">Toggle Dark</button>
                <button
                  onClick={()=>setRecoveryMode(m=> m==="inline" ? "gate" : "inline")}
                  className="text-sm text-teal-400 underline"
                >
                  Recovery: {recoveryMode === "gate" ? "Gate" : "Inline"}
                </button>
              </div>
              <div className="flex gap-2">
                <button onClick={onHiit} className="text-sm text-blue-400 underline">I Feel Like HIIT Today</button>
                <button onClick={onRestart} className="text-sm text-amber-400 underline">Restart</button>
              </div>
            </div>
          </header>
        );
      }

      function ModalityToggles({ modality, setModality, lastModalityVisual }) {
        function Item({ id, label }){
          const active = (modality===id);
          const wasLast = (id===lastModalityVisual);
          let base = "px-3 py-2 rounded-lg cursor-pointer text-sm relative transition";
          let cls = base + " ";
          if (active && wasLast) {
            cls += "bg-blue-600 text-white ring-2 ring-red-400";
          } else if (active) {
            cls += "bg-blue-600 text-white";
          } else if (wasLast) {
            cls += "bg-gray-200 dark:bg-gray-800 ring-2 ring-red-400";
          } else {
            cls += "bg-gray-200 dark:bg-gray-800";
          }
          return (
            <label className={cls} title={wasLast ? "Last used" : ""}>
              <input type="radio" name="modality" className="hidden" checked={active} onChange={()=>setModality(id)} />
              {label}
              {wasLast && <span className="absolute -top-1 -right-1 w-2.5 h-2.5 bg-red-500 rounded-full" aria-hidden />}
            </label>
          );
        }
        return (
          <div className="flex flex-wrap gap-2 justify-center mb-3">
            <Item id="kettlebell" label="Kettlebell" />
            <Item id="barbell" label="Barbell" />
            <Item id="bodyweight" label="Bodyweight" />
          </div>
        );
      }

      function Timer({ elapsed, setElapsed, running, setRunning }) {
        const ref=useRef(null);
        useEffect(()=>{
          if(running){ ref.current=setInterval(()=>setElapsed(t=>t+1),1000); }
          else if(ref.current){ clearInterval(ref.current); ref.current=null; }
          return ()=>{ if(ref.current){ clearInterval(ref.current); ref.current=null; } };
        },[running,setElapsed]);
        return (
          <div className="p-4 card mb-4">
            <p className="text-xl font-mono text-center">{fmtHMS(elapsed)}</p>
            <div className="flex gap-2 mt-2">
              <button className="btn bg-green-600 w-full" onClick={()=>setRunning(true)}>Start</button>
              <button className="btn bg-yellow-500 text-black w-full" onClick={()=>setRunning(false)}>Stop</button>
              <button className="btn bg-gray-600 w-full" onClick={()=>{ setElapsed(0); setRunning(false); }}>Reset</button>
            </div>
          </div>
        );
      }

      function SessionView({ session }) {
        if(!session) return null;
        const m=session.meta||{};
        const isHIIT = m.modality==='hiit';
        const isRecovery = m.modality==='recovery';
        const isBreathing = m.modality==='breathing';
        const isWarmup = m.modality==='warmup';
        const title = isHIIT
          ? `Inferno${m.su?` • ${m.su} SU`:''}${m.date ? ` • ${new Date(m.date).toLocaleDateString()}` : ''}`
          : isRecovery
            ? `Active Recovery${m.choice?` • ${m.choice}`:''}`
            : isBreathing
              ? `Breathing${m.minutes?` • ${m.minutes} min`:''}${m.date?` • ${new Date(m.date).toLocaleDateString()}`:''}`
              : isWarmup
                ? `Warm-up`
                : (m.cycle && m.phase && m.session) ? `${(m.modality||'Session')[0].toUpperCase()}${(m.modality||'session').slice(1)} ${m.cycle}.${m.phase}.${m.session}` : `Today's Session`;

        return (
          <div className="p-4 card mb-4">
            <h2 className="font-semibold mb-2 text-lg">{title}</h2>
            <div className="text-base space-y-1">
              {renderSmartList(session.main || [])}
            </div>
            <p className="text-xs text-gray-400 mt-2">Pinned until you press “Complete”.</p>
          </div>
        );
      }

      function History({ modality }) {
        const key=`history:${modality}`;
        const [items,setItems]=useState(lsGet(key,[]));
        const [open,setOpen]=useState(false);
        useEffect(()=>{ setItems(lsGet(key,[])); },[modality,open]);
        if(!items || items.length===0) return <div className="mb-4 text-sm text-gray-400">History (empty)</div>;
        const sorted=[...items].sort((a,b)=> new Date(b.saved_at) - new Date(a.saved_at));
        return (
          <div className="mb-4">
            <button className="text-sm underline" onClick={()=>setOpen(o=>!o)}>{open?'Hide History':`Show History (${items.length})`}</button>
            {open && (
              <div className="mt-2 space-y-2">
                {sorted.map((h,idx)=>(
                  <div key={idx} className="p-3 card">
                    <div className="text-sm flex flex-wrap gap-3">
                      <span className="font-medium">{(h.meta&&h.meta.modality||'').toUpperCase()}</span>
                      {h.meta&&h.meta.choice && <span>• {h.meta.choice}</span>}
                      {h.meta&&h.meta.cycle!=null&&h.meta.phase!=null&&h.meta.session!=null && <span>• {h.meta.cycle}.{h.meta.phase}.{h.meta.session}</span>}
                      {h.meta && h.meta.date && <span>• {new Date(h.meta.date).toLocaleString()}</span>}
                      <span>• {new Date(h.saved_at).toLocaleString()}</span>
                      {h.timer_seconds>0 && <span>• Time: {fmtHMS(h.timer_seconds)}</span>}
                      {h.meta&&h.meta.su && <span>• {h.meta.su} SU</span>}
                      {h.meta&&h.meta.protocol && <span>• {h.meta.protocol} {h.meta.minutes}m</span>}
                      {h.meta&&h.meta.performance && (h.meta.performance.load || h.meta.performance.rpe) && (
                        <span>• Load/RPE: {h.meta.performance.load||'-'}/{h.meta.performance.rpe||'-'}</span>
                      )}
                    </div>
                    <div className="text-sm mt-1">
                      {renderSmartList(h.main || [])}
                    </div>
                  </div>
                ))}
              </div>
            )}
          </div>
        );
      }

      function RecoveryGate({ recovery, setRecovery, onConfirm, onSkip }) {
        return (
          <div className="p-4 card mb-4">
            <p className="font-semibold mb-2">Daily Recovery Check</p>
            <div className="grid grid-cols-1 md:grid-cols-3 gap-3 mb-2">
              {[
                ['sleep','Sleep'],['energy','Energy'],['body','Body']
              ].map(([k,l])=>(
                <div key={k} className="flex items-center gap-3">
                  <span className="w-16">{l}</span>
                  <input
                    type="range" min="0" max="5" value={recovery[k]}
                    className="w-full h-4"
                    onChange={e=>{
                      const next={...recovery,[k]:parseInt(e.target.value,10)};
                      next.total=next.sleep+next.energy+next.body;
                      next.gate=next.total>=11?'TRAIN':next.total>=7?'ACTIVE RECOVERY':'FULL REST';
                      setRecovery(next);
                    }}
                  />
                  <span className="w-6 text-center">{recovery[k]}</span>
                </div>
              ))}
            </div>
            <p className="text-sm">Total: {recovery.total||0} → <strong>{recovery.gate||'FULL REST'}</strong></p>
            <div className="flex flex-col md:flex-row gap-2 mt-3">
              <button className="btn bg-blue-600 w-full" onClick={()=>onConfirm()}>Continue</button>
              <button className="btn bg-gray-600 w-full" onClick={onSkip}>Skip today</button>
            </div>
            <p className="text-xs text-gray-400 mt-2">We remember your choice until midnight.</p>
          </div>
        );
      }

      /* ========== Performance form (Load/RPE/Notes) ========== */
      function PerformanceForm({ session, onChange }){
        const m = session?.meta || {};
        const perf = m.performance || { load:"", rpe:"", notes:"" };
        const isStrength = ["kettlebell","barbell","bodyweight"].includes(m.modality);
        if(!isStrength) return null;
        return (
          <div className="p-4 card mb-4">
            <p className="font-semibold mb-2">Performance</p>
            <div className="grid grid-cols-1 md:grid-cols-3 gap-2">
              <div>
                <label className="text-xs text-gray-400">Load</label>
                <input className="w-full px-2 py-1 rounded bg-gray-800"
                       value={perf.load}
                       onChange={e=>onChange({...perf, load:e.target.value})}/>
              </div>
              <div>
                <label className="text-xs text-gray-400">RPE (1–10)</label>
                <input className="w-full px-2 py-1 rounded bg-gray-800"
                       type="number" min="1" max="10"
                       value={perf.rpe}
                       onChange={e=>onChange({...perf, rpe:e.target.value})}/>
              </div>
              <div className="md:col-span-3">
                <label className="text-xs text-gray-400">Notes</label>
                <textarea className="w-full px-2 py-1 rounded bg-gray-800" rows="3"
                          value={perf.notes}
                          onChange={e=>onChange({...perf, notes:e.target.value})}/>
              </div>
            </div>
          </div>
        );
      }

      /* ========== Export helpers ========== */
      function collectAllHistory(){
        const out = {};
        for(let i=0;i<localStorage.length;i++){
          const k = localStorage.key(i);
          if(k && k.startsWith('history:')){
            out[k] = lsGet(k,[]);
          }
        }
        return out;
      }
      function exportJSON(){
        const data = collectAllHistory();
        const blob = new Blob([JSON.stringify(data,null,2)], {type:"application/json"});
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url; a.download = `everstrong-history-${new Date().toISOString().slice(0,10)}.json`;
        document.body.appendChild(a); a.click(); a.remove();
        URL.revokeObjectURL(url);
      }
      function toCSV(rows){
        const esc = v => `"${String(v??"").replace(/"/g,'""')}"`;
        const header = ["saved_at","modality","choice","cycle","phase","session","date","timer_seconds","su","protocol","minutes","performance_load","performance_rpe","notes","lines"];
        const out = [header.join(",")];
        rows.forEach(r=>{
          const m=r.meta||{};
          out.push([
            r.saved_at||"",
            m.modality||"",
            m.choice||"",
            m.cycle??"",
            m.phase??"",
            m.session??"",
            m.date?new Date(m.date).toISOString():"",
            r.timer_seconds??"",
            m.su??"",
            m.protocol||"",
            m.minutes??"",
            m.performance?.load||"",
            m.performance?.rpe||"",
            m.performance?.notes? m.performance.notes.replace(/\n/g,' ') : "",
            (r.main||[]).join(" | ")
          ].map(esc).join(","));
        });
        return out.join("\n");
      }
      function exportCSV(){
        const all = collectAllHistory();
        const rows = Object.values(all).flat();
        const csv = toCSV(rows);
        const blob = new Blob([csv], {type:"text/csv"});
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url; a.download = `everstrong-history-${new Date().toISOString().slice(0,10)}.csv`;
        document.body.appendChild(a); a.click(); a.remove();
        URL.revokeObjectURL(url);
      }

      /* ========== App ========== */
      function App(){
        const [modality,setModality]=useState(lsGet("modality","kettlebell"));
        useEffect(()=>lsSet("modality",modality),[modality]);

        const [session,setSession]=useState(null);
        const [elapsed,setElapsed]=useState(0);
        const [running,setRunning]=useState(false);
        const [recovery,setRecovery]=useState({sleep:0,energy:0,body:0,total:0,gate:"FULL REST"});

        const [recoveryMode, setRecoveryMode] = useState(lsGet("recovery:mode","gate"));
        useEffect(()=>lsSet("recovery:mode", recoveryMode),[recoveryMode]);

        // route: show full-screen gate if in gate-mode and not confirmed today
        const [route, setRoute] = useState("gate");
        useEffect(()=>{
          if(recoveryMode==="gate"){
            const stamp = lsGet("recovery:stamp", null);
            const today = todayStr();
            setRoute(stamp===today ? lsGet("recovery:lastRoute","train") : "gate");
          } else {
            setRoute("train");
          }
        },[recoveryMode]);
        useEffect(()=>{
          if(recoveryMode === "gate"){ setRoute("gate"); }
        },[recoveryMode]);

        const [activeRecoveryChoice, setActiveRecoveryChoice] = useState(null);

        const [lastModalityStored, setLastModalityStored] = useState(lsGet("last_modality", null));
        const lastModalityVisual = useMemo(()=>{
          return getLatestMainModalityFromHistory() || lastModalityStored || null;
        }, [session, route, lastModalityStored, modality, recoveryMode]);

        const currentKey = (m) => `current:${m}`;
        const historyKey = (m) => `history:${m}`;

        function engineFor(m){ return m==='kettlebell'?SFG : m==='barbell'?SFL : SFB; }

        useEffect(()=>{
          const cur=lsGet(currentKey(modality),null);
          setSession(cur);
          setElapsed(0); setRunning(false);
        },[modality]);

        function toggleDark(){ document.documentElement.classList.toggle('dark'); }

        function lockToday(routeChosen){
          lsSet("recovery:stamp", todayStr());
          lsSet("recovery:lastRoute", routeChosen);
        }
        function decideGate(total){
          if(total>=11) return "train";
          if(total>=7)  return "recovery";
          return "fullrest";
        }
        function handleGateConfirm(){
          const routeChosen = decideGate(recovery.total||0);
          lockToday(routeChosen);
          setRoute(routeChosen);
          setActiveRecoveryChoice(null);
        }
        function handleGateSkip(){
          lockToday("train");
          setRoute("train");
        }

        function restartSelected(){
          if(session && session.meta && ['hiit','recovery','breathing','warmup'].includes(session.meta.modality)){
            try{localStorage.removeItem(currentKey(session.meta.modality));}catch(e){}
          }
          const eng=engineFor(modality);
          eng.hardResetToStart();
          try{localStorage.removeItem(currentKey(modality));}catch(e){ }
          setSession(null); setElapsed(0); setRunning(false);
          alert('Reset to 1.1.1 for '+modality);
        }
        function generateCycle(){
          const eng=engineFor(modality);
          eng.hardResetToStart();
          const s=eng.generate_single_session();
          s.meta.modality=modality;
          lsSet(currentKey(modality),s);
          setSession(s);
          setElapsed(0); setRunning(false);
        }
        function saveToHistory(s, mod){
          const m = mod || modality;
          const arr=lsGet(historyKey(m),[]);
          arr.push({ saved_at:new Date().toISOString(), timer_seconds:elapsed||0, main:s.main, meta:s.meta });
          lsSet(historyKey(m),arr);
        }
        function completeSession(){
          if(!session) return;
          setRunning(false);
          const metaMod = session.meta && session.meta.modality;
          saveToHistory(session, metaMod ? metaMod : modality);
          setElapsed(0);
          if(!metaMod){ lsSet("last_modality", modality); setLastModalityStored(modality); }
          const special = ['hiit','recovery','breathing','warmup'];
          if(special.includes(metaMod)){
            try{localStorage.removeItem(currentKey(metaMod));}catch(e){}
            setSession(null);
            alert(`${metaMod==='hiit'?'Inferno':metaMod==='recovery'?'Active Recovery':metaMod==='warmup'?'Warm-up':'Breathing'} saved to history.`);
            return;
          }
          const eng=engineFor(modality);
          const s=eng.generate_single_session();
          s.meta.modality=modality;
          lsSet(currentKey(modality),s);
          setSession(s);
        }
        function updatePerformance(perf){
          if(!session) return;
          const next = { ...session, meta: { ...session.meta, performance: perf } };
          lsSet(`current:${session.meta?.modality || modality}`, next);
          setSession(next);
        }

        // ==== Inferno ====
        function triggerInferno(target){
          if(typeof window.HELLFIRE_GENERATE!=='function'){ alert('Inferno engine missing'); return; }
          const out = window.HELLFIRE_GENERATE(target);
          const now = new Date().toISOString();
          const hiitSession = { main: out.lines, meta: { modality:'hiit', su: out.su||target, date: now } };
          lsSet(currentKey('hiit'), hiitSession);
          setModality('hiit'); setSession(hiitSession);
          setElapsed(0); setRunning(false);
        }
        function openHiitChooser(){
          setModality('hiit');
          const existing=lsGet(currentKey('hiit'),null);
          setSession(existing);
          setElapsed(0); setRunning(false);
        }

        // ==== Warm-up (fixed routine) ====
        function openWarmup(){
          const lines = [
            "Warm-up — do between 10 reps and your age per movement",
            "",
            "* Three-Way Neck",
            "* Fingers and Wrists",
            "* Elbow Circles",
            "* Kettlebell Halo",
            "* Egyptian",
            "* Hip Circles",
            "* Knee Circles",
            "* Toes, Feet, and Ankles",
            "* Crocodile Breathing",
            "* Prying Cobra / Down Dog",
            "* Cat-Camel (McGill)",
            "* Frog",
            "* Tug-of-War Squats"
          ];
          const wSession = { main: lines, meta: { modality:'warmup', date:new Date().toISOString() } };
          lsSet(currentKey('warmup'), wSession);
          setModality('bodyweight'); // neutral UI
          setSession(wSession);
          setElapsed(0); setRunning(false);
        }

        // ==== Active Recovery (pin all options) ====
        function chooseMobility(){
          setActiveRecoveryChoice("A");
          const lines = [
            "Mobility — do 5–10 smooth reps per movement",
            "",
            "Hips",
            "* Figure 4 position",
            "* Figure 4 lunge",
            "* Half heel sit",
            "* Z position switches & Z position side roll",
            "* Hip Openers – Prone → TGU → Bridge",
            "",
            "Shoulders",
            "* The Egyptian (Seated, Pike, Prone)",
            "* S movement (Seated, Pike, Prone)",
            "* Figure 8 in Crawl (6-point & 4-point)",
            "* Crawl → Crab",
            "* Pike → Tabletop",
            "",
            "Ankles",
            "* Ankle series (Up & down, In & out, Rotations)",
            "* Figure 8’s (toes & ankle)",
            "* Snail",
            "* Crawl → Frog → Crab transitions",
            "",
            "Spine & Neck",
            "* Supine neck rolls (L ↔ R)",
            "* Hand on knee rolling",
            "* Segmental rolling (Neck, arms & legs)",
            "* Forward & backward rolling",
            "",
            "Wrists",
            "* Finger waves",
            "* Hand circles",
            "* Teapot"
          ];
          const recSession = { main: lines, meta: { modality:'recovery', date:new Date().toISOString(), choice:'Mobility' } };
          lsSet(`current:recovery`, recSession);
          setSession(recSession);
          setElapsed(0); setRunning(false);
        }
        function chooseFlowPlusZone2(){
          setActiveRecoveryChoice("B");
          const flow = (typeof window.GFM_FLOW_GENERATE==='function') ? window.GFM_FLOW_GENERATE() : ["Flow generator unavailable."];
          const lines = ["Flow (~20 min):", ...flow, "", "Then: 30 min Zone 2 cardio (run/bike/row)"];
          const recSession = { main: lines, meta: { modality:'recovery', date:new Date().toISOString(), choice:'Flow + Zone 2' } };
          lsSet(`current:recovery`, recSession);
          setSession(recSession);
          setElapsed(0); setRunning(false);
        }
        function chooseZone2Only(){
          setActiveRecoveryChoice("C");
          const lines = ["Zone 2 only:", "* Do 30 min continuous Zone 2 cardio (run, bike, row, etc.)."];
          const recSession = { main: lines, meta: { modality:'recovery', date:new Date().toISOString(), choice:'Zone 2' } };
          lsSet(`current:recovery`, recSession);
          setSession(recSession);
          setElapsed(0); setRunning(false);
        }

        // ==== Breathing ====
        function createBreathingPinned(protocolKey, minutes){
          const proto = BREATH_PROTOCOLS[protocolKey];
          const lines = [
            `Breathing — ${proto.name}`,
            `* Duration: ${minutes} min`,
            `* Best for: ${proto.best}`,
            "",
            "Tips",
            "* Nasal breathing",
            "* Relax shoulders/jaw, soft belly breath"
          ];
          const brSession = { main: lines, meta: { modality:'breathing', protocol: proto.name, minutes, date: new Date().toISOString() } };
          lsSet(`current:breathing`, brSession);
          setSession(brSession);
          setElapsed(0); setRunning(false);
        }
        function autoCompleteBreathing(protocolKey, minutes){
          const proto = BREATH_PROTOCOLS[protocolKey];
          const lines = [
            `Breathing — ${proto.name}`,
            `* Duration: ${minutes} min`,
            `* Best for: ${proto.best}`,
            "",
            "Tips",
            "* Nasal breathing",
            "* Relax shoulders/jaw, soft belly breath"
          ];
          const brSession = { main: lines, meta: { modality:'breathing', protocol: proto.name, minutes, date: new Date().toISOString() } };
          lsSet(`current:breathing`, brSession);
          setSession(brSession);
          setElapsed(minutes*60);
        }

        /* ===== FULL-SCREEN GATE ===== */
        if (recoveryMode==="gate" && route==="gate") {
          return (
            <div className="mx-auto w-full max-w-md md:max-w-2xl min-h-screen flex items-start pt-4">
              <div className="w-full px-4">
                <div className="text-center mb-3">
                  <h1 className="text-3xl font-bold">EverStrong</h1>
                  <p className="text-gray-500 dark:text-gray-400 text-sm">Daily Recovery Check</p>
                </div>
                <RecoveryGate
                  recovery={recovery}
                  setRecovery={setRecovery}
                  onConfirm={handleGateConfirm}
                  onSkip={handleGateSkip}
                />
                <p className="text-[11px] text-center text-gray-500 mt-3">You’ll see training options after you confirm.</p>
              </div>
            </div>
          );
        }

        const hasPinned = !!session;
        const isHIIT = modality==='hiit';

        return (
          <div className="mx-auto w-full max-w-md md:max-w-2xl">
            <Header
              onHiit={openHiitChooser}
              onToggleDark={toggleDark}
              onRestart={restartSelected}
              recoveryMode={recoveryMode}
              setRecoveryMode={setRecoveryMode}
            />

            {/* Inline Recovery mode (sliders inline on top) */}
            {recoveryMode==="inline" && (
              <div className="p-4 card mb-4">
                <p className="font-semibold mb-2">Recovery Check</p>
                <div className="grid grid-cols-1 md:grid-cols-3 gap-3 mb-2">
                  {[
                    ['sleep','Sleep'],['energy','Energy'],['body','Body']
                  ].map(([k,l])=>(
                    <div key={k} className="flex items-center gap-3">
                      <span className="w-16">{l}</span>
                      <input type="range" min="0" max="5" value={recovery[k]} className="w-full h-4"
                        onChange={e=>{
                          const next={...recovery,[k]:parseInt(e.target.value,10)};
                          next.total=next.sleep+next.energy+next.body;
                          next.gate=next.total>=11?'TRAIN':next.total>=7?'ACTIVE RECOVERY':'FULL REST';
                          setRecovery(next);
                        }}/>
                      <span className="w-6 text-center">{recovery[k]}</span>
                    </div>
                  ))}
                </div>
                <p className="text-sm">Total: {recovery.total||0} → <strong>{recovery.gate||'FULL REST'}</strong></p>
                {recovery.total>=7 && recovery.total<=10 && (
                  <>
                    <p className="text-xs text-gray-400 mt-3">Active Recovery — Choose:</p>
                    <div className="flex flex-col gap-2 mt-2">
                      <button className="btn bg-gray-700 w-full" onClick={chooseMobility}>Mobility</button>
                      <button className="btn bg-gray-700 w-full" onClick={chooseFlowPlusZone2}>Flow + Zone 2</button>
                      <button className="btn bg-gray-700 w-full" onClick={chooseZone2Only}>Zone 2</button>
                    </div>
                  </>
                )}
              </div>
            )}

            {/* Modality */}
            <ModalityToggles
              modality={isHIIT?'bodyweight':modality}
              setModality={m=>{ if(m==='hiit')return; setModality(m); }}
              lastModalityVisual={getLatestMainModalityFromHistory() || lsGet("last_modality", null) || null}
            />

            {/* Actions: for HIIT extras */}
            <div className="p-4 card mb-4">
              <div className="flex flex-col gap-2">
                {session && session.meta && session.meta.modality === 'hiit' ? (
                  <div className="flex flex-col md:flex-row gap-2">
                    {[300,400,500].map(val=>(
                      <button key={val} onClick={()=>triggerInferno(val)} className="btn bg-blue-600 w-full">
                        New Inferno {val}
                      </button>
                    ))}
                  </div>
                ) : (
                  !hasPinned && (
                    <button onClick={generateCycle} className="btn bg-blue-600 w-full">
                      Generate Cycle (start at 1.1.1)
                    </button>
                  )
                )}
                {/* I Feel Like HIIT Today */}
                <button onClick={openHiitChooser} className="btn bg-indigo-600 w-full">
                  I Feel Like HIIT Today
                </button>
              </div>
            </div>

            <SessionView session={session}/>

            {/* Under the pinned session: small Complete + Warm-up */}
            <div className="flex gap-2 mb-4">
              <button
                onClick={completeSession}
                className="btn-sm bg-green-600 w-1/2"
                disabled={!session}
                title={!session ? "No pinned session" : "Save this session"}
              >
                Complete
              </button>
              {/* Hide warm-up button if the pinned session IS the warm-up */}
              {!(session && session.meta && session.meta.modality==='warmup') && (
                <button
                  onClick={openWarmup}
                  className="btn-sm bg-emerald-700 w-1/2"
                  title="Open fixed warm-up routine"
                >
                  Warm-up
                </button>
              )}
            </div>

            <PerformanceForm session={session} onChange={updatePerformance}/>
            <Timer elapsed={elapsed} setElapsed={setElapsed} running={running} setRunning={setRunning} />

            {/* History tabs */}
            <History modality={(session && session.meta && session.meta.modality) ? session.meta.modality : (isHIIT?'hiit':modality)} />
            <History modality="warmup" />
            <History modality="breathing" />

            {/* Export */}
            <div className="p-4 card mb-4">
              <p className="font-semibold mb-2">Export</p>
              <div className="flex gap-2">
                <button className="btn bg-gray-700 w-full" onClick={exportJSON}>Export JSON</button>
                <button className="btn bg-gray-700 w-full" onClick={exportCSV}>Export CSV</button>
              </div>
            </div>

            <footer className="text-xs text-center mt-6 text-gray-400 pb-[calc(env(safe-area-inset-bottom)+8px)]">
              Kettlebell • Barbell • Bodyweight • Inferno • Warm-up • Recovery • Breathing
            </footer>
          </div>
        );
      }

      ReactDOM.createRoot(document.getElementById('root')).render(<App/>);
    </script>
  </body>
</html>

