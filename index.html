<!DOCTYPE html>
<html lang="en" class="dark">
<head>
  <meta charset="UTF-8" />
  <title>EverStrong</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover"/>
  <script src="https://cdn.tailwindcss.com"></script>
  <script>tailwind.config={darkMode:'class'}</script>
  <script src="https://unpkg.com/react@18/umd/react.development.js"></script>
  <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  <style>
    :root { color-scheme: light dark; }
    body { -webkit-font-smoothing: antialiased; -webkit-tap-highlight-color: transparent; }
    .btn { border-radius:.9rem; padding:.75rem 1rem; }
    .btn-sm { border-radius:.7rem; padding:.5rem .75rem; font-size:.9rem; }
    .safe { padding-left: max(1rem, env(safe-area-inset-left)); padding-right: max(1rem, env(safe-area-inset-right)); }
    .pill { border:1px solid rgba(255,255,255,.12); border-radius:999px; padding:.35rem .7rem; font-size:.8rem; }
  </style>
</head>
<body class="bg-gray-100 dark:bg-gray-900 dark:text-gray-100 min-h-screen">
  <div id="root" class="safe py-3"></div>

  <script type="text/babel" data-presets="env,react">
    const { useState, useEffect, useRef, useMemo } = React;

    /* ================== Utils ================== */
    function lsGet(k, f){ try{ const v=localStorage.getItem(k); return v? JSON.parse(v): f; } catch(e){ return f; } }
    function lsSet(k, v){ try{ localStorage.setItem(k, JSON.stringify(v)); } catch(e){} }
    function fmtHMS(secs){
      const s=Math.max(0,Math.floor(secs));
      const hh=('0'+Math.floor(s/3600)).slice(-2);
      const mm=('0'+Math.floor((s%3600)/60)).slice(-2);
      const ss=('0'+(s%60)).slice(-2);
      return `${hh}:${mm}:${ss}`;
    }
    function todayStr(){ return new Date().toDateString(); }
    function todayKey(){
      const d=new Date(); const y=d.getFullYear(); const m=('0'+(d.getMonth()+1)).slice(-2); const day=('0'+d.getDate()).slice(-2);
      return `${y}-${m}-${day}`;
    }
    function getLatestMainModalityFromHistory(){
      const keys = ["history:kettlebell","history:barbell","history:bodyweight"];
      let best = null, bestDate = 0;
      keys.forEach(k=>{
        const arr = lsGet(k,[]);
        if (!Array.isArray(arr) || arr.length===0) return;
        const last = arr.reduce((a,b)=> new Date(a.saved_at)>new Date(b.saved_at)?a:b);
        const t = new Date(last.saved_at).getTime();
        if (t > bestDate) { bestDate = t; best = k.split(":")[1]; }
      });
      return best;
    }
    function addDays(dateISO, days){
      const d = dateISO ? new Date(dateISO) : new Date();
      d.setHours(0,0,0,0);
      d.setDate(d.getDate()+days);
      return d.toISOString();
    }
    function isSameOrBefore(aISO, bISO){
      return new Date(aISO).getTime() <= new Date(bISO).getTime();
    }
    function todayISO(){ const d=new Date(); d.setHours(0,0,0,0); return d.toISOString(); }
    // --- Video link helpers ---
    function getVideoLinks(){ return lsGet('video:links', {}); }
    function saveVideoLink(name, url){
      const map = getVideoLinks();
      if(!url){ delete map[name]; } else { map[name] = url; }
      lsSet('video:links', map);
    }

    // --- YouTube helpers ---
    function getYouTubeId(url){
      if(!url) return null;
      try{
        const u = new URL(url);
        if(u.hostname.includes('youtu.be')){
          const id = u.pathname.split('/').filter(Boolean)[0];
          return id || null;
        }
        if(u.hostname.includes('youtube.com') || u.hostname.includes('m.youtube.com')){
          const v = u.searchParams.get('v');
          if(v) return v;
          const shorts = u.pathname.match(/\/shorts\/([^/?#]+)/);
          if(shorts) return shorts[1];
          const embed = u.pathname.match(/\/embed\/([^/?#]+)/);
          if(embed) return embed[1];
        }
      }catch(e){}
      return null;
    }
    function getYouTubeThumb(id, quality='mq'){
      const q = quality==='hq' ? 'hqdefault.jpg' : quality==='mq' ? 'mqdefault.jpg' : 'default.jpg';
      return `https://img.youtube.com/vi/${id}/${q}`;
    }
// --- Last-Load helpers (per oefening) ---
function getLastLoads(){ return lsGet('load:last', {}); }
function saveLastLoad(name, data){
  const map = getLastLoads();
  map[name] = { ...(map[name]||{}), ...(data||{}) };
  lsSet('load:last', map);
}
function getLastLoadFor(name){
  const map = getLastLoads();
  return map[name] || null; // bv. { load:"80 kg", rpe:"7", date:"2025-09-15T10:00:00Z" }
}
    // --- Eénmalige seed van YouTube-links (non-destructief) ---
    const VIDEO_LINKS_SEED = {
  // Kettlebell — KETTLEBELLENGINE
  "One-Legged Deadlift": "https://www.youtube.com/watch?v=wW57VmUxefg",
  "Double Sumo Deadlift": "https://www.youtube.com/watch?v=ymDxI-3cgoI",
  "Single Leg Glute Bridge": "https://www.youtube.com/shorts/dgJoc5mbNzA",
  "One-arm Swing": "https://www.youtube.com/watch?v=UYBKrK1y6ww",
  "(Side Stepping) Two-arm Swing": "https://www.youtube.com/watch?v=UwYcntzzUiU",
  "Double Swing": "https://www.youtube.com/shorts/0f5oD464u1Q",

  "(3 Min) Get Up": "https://www.youtube.com/watch?v=sgd8n917Zv0",
  "Supine to Sit Up": "https://www.youtube.com/watch?v=dv_nNf43Qck",
  "Windmill": "https://www.youtube.com/shorts/EZWHnzAjctU",
  "Bent Press": "https://www.youtube.com/watch?v=cFmSd61PPTI",
  "Supine to Bridge": "https://www.youtube.com/watch?v=r_sJKLowdak",
  "Supine to Half Kneel": "https://www.youtube.com/watch?v=r_sJKLowdak",
  "Half Kneel to Stand": "https://www.youtube.com/watch?v=1XOHgBZlCpo",

  "HS-Plank": "https://www.youtube.com/watch?v=w_KhpjMWVNM",
  "Front Rack Carry": "https://www.youtube.com/watch?v=jumVlXfY1Pc",
  "Single Dead Clean": "https://www.youtube.com/shorts/WFnnHBpvttE",
  "Double Clean": "https://www.youtube.com/shorts/gEWRc6rWFkg",
  "Pullover": "https://www.youtube.com/watch?v=1-3Ul1YgPOg",
  "One-arm Row": "https://www.youtube.com/shorts/pvRXtyBkO-s",

  "B-stance Goblet Squat": "https://www.youtube.com/shorts/QEZpCqjzHAA",
  "Single Front Squat": "https://www.youtube.com/watch?v=SlPwjU6I9gk",
  "Paused Front Squat": "https://www.youtube.com/shorts/B7v20H9NAmI",
  "Double Front Squat": "https://www.youtube.com/shorts/l3TxmNX6C8s",
  "Athletic Lunge": "https://www.youtube.com/shorts/nDFVS8Hg3xw",
  "Bottom Up Squat": "https://www.youtube.com/shorts/d8jEluh8tFc",

  "Military Press": "https://www.youtube.com/shorts/oYubnI4aXD8",
  "Top Down Press": "https://www.youtube.com/shorts/ezAs5iMjy0A",
  "Half Kneeling Press": "https://www.youtube.com/shorts/n0peUzKZ-PU",
  "Floor Press": "https://www.youtube.com/shorts/1QMCUbRkQFA",
  "Double Push Press": "https://www.youtube.com/watch?v=WwluL1MF0jA",
  "Double Push Jerk": "https://www.youtube.com/shorts/FhzocaH1MFs",

  "Overhead Carry": "https://www.youtube.com/watch?v=54POVWkWjEs",
  "Snatch": "https://www.youtube.com/watch?v=QsuJ6973OFc",
  "Low Pull Snatch": "https://www.youtube.com/shorts/GK8i2xYGaOM",
  "High Pull": "https://www.youtube.com/watch?v=mP1BHxBeAEM",
  "Front/Side Raise Snatch": "https://www.youtube.com/shorts/7uPCrlXxW8s",
  "Double Snatch": "https://www.youtube.com/shorts/3Y73hcmzSN0",

  "Double Clean & Press": "https://www.youtube.com/shorts/S6o26rzFPEs",
  "Double Clean & Front Squat": "https://www.youtube.com/watch?v=t7vqdHxMVGY",
  "Double Snatch & Overhead Walk": "https://www.youtube.com/shorts/O_jKGm7UjWE",
  "Double Clean & Jerk": "https://www.youtube.com/shorts/tonuNZZTPlA",
  "Double Snatch & Press": "https://www.youtube.com/watch?v=bsJpa1Bhe84",
  "Double Front Squat & Push Press": "https://www.youtube.com/shorts/HsAwg5kCORg",

  // Barbell — BARBELLENGINE
  "Back Squat": "https://www.youtube.com/watch?v=-bJIpOq-LWk",
  "Front Squat": "https://www.youtube.com/watch?v=HHxNbhP16UE",
  "Zercher Squat": "https://www.youtube.com/shorts/3F9ZohTI-lg",

  "Bench Press": "https://www.youtube.com/shorts/hWbUlkb5Ms4",
  "Incline Bench Press": "https://www.youtube.com/watch?v=lJ2o89kcnxY",
  "Shoulder Press": "https://www.youtube.com/watch?v=G2qpTG1Eh40",

  "Conventional Deadlift": "https://www.youtube.com/shorts/ZaTM37cfiDs",
  "Goodmorning": "https://www.youtube.com/shorts/7cpldMZjLOs",
  "Sumo Deadlift": "https://www.youtube.com/watch?v=pfSMst14EFk",

  // Bodyweight — BODYWEIGHTENGINE
  "Box Pistol": "https://www.youtube.com/watch?v=ctffzu0jWu0",
  "Top Down Pistol": "https://www.youtube.com/shorts/D5Iib9ZEkk8",
  "Full Pistol": "https://www.youtube.com/shorts/AF3rz1fOIFk",

  "One-arm One-leg Push Up": "https://www.youtube.com/shorts/wnggEdKfySU",
  "Wall HSPU (assist)": "https://www.youtube.com/watch?v=0wDEO6shVjc",
  "Dips": "https://www.youtube.com/watch?v=Vt0lO4jpIDo",

  "Tactical Pull Up": "https://www.youtube.com/watch?v=AcI6bGetbBU",
  "Hanging Leg Raise": "https://www.youtube.com/watch?v=7FwGZ8qY5OU",
  "Front Lever (prog)": "https://www.youtube.com/shorts/pDSQrioCAP0",

  // === Inferno (HIIT) – Squat (statisch) ===
  "Jump Squat (BW)": "https://www.youtube.com/shorts/0Gccogfw9-8",
  "Split Squat Jump (BW)": "https://www.youtube.com/watch?v=cIkkHg8YZQU",
  "Cossack Squat (KB)": "https://www.youtube.com/shorts/XvJ8gtW30ZA",
  "Goblet Thruster (KB)": "https://www.youtube.com/shorts/xCWW75WMGQc",
  "Box Jump (BW)": "https://www.youtube.com/shorts/7EfeTsHZ5vkx",
  "Box step Over (KB)": "https://www.youtube.com/watch?v=nemACX62EVY",

  // === Inferno (HIIT) – Hinge ===
  "One-arm Swing (KB)": "https://www.youtube.com/shorts/HX6f7I0IpCI",
  "Hand-to-Hand Swing (KB)": "https://www.youtube.com/shorts/menvc5lfMfg",
  "Broad Jump (BW)": "https://www.youtube.com/shorts/v0yrBWA3eEs",
  "Two-arm Swing (KB)": "https://www.youtube.com/watch?v=LDfiVzjGjAg",
  "Snatch (KB)": "https://www.youtube.com/watch?v=QsuJ6973OFc",
  "Deadlift Jump (KB)": "https://www.youtube.com/watch?v=ZL-lrmnIXY4",

  // === Inferno (HIIT) – Push ===
  "Plyo Push-up (BW)": "https://www.youtube.com/watch?v=hDP-oskzYUs",
  "Push Press (KB)": "https://www.youtube.com/watch?v=CCqru4q9RK0",
  "Push Jerk (KB)": "https://www.youtube.com/watch?v=SQ4fdVPMIng",
  "Clean & Push Press (BW)": "https://www.youtube.com/shorts/TjWVpKqS990",
  "Dips (BW)": "https://www.youtube.com/shorts/SXBksC78v8M",
  "Viking Push Press (KB)": "https://www.youtube.com/watch?v=p-RKLmZmlqw",

  // === Inferno (HIIT) – Pull ===
  "High Pull (KB)": "https://www.youtube.com/watch?v=mP1BHxBeAEM",
  "Explosive Row (KB)": "https://www.youtube.com/watch?v=JlOhApM2aFw",
  "Jumping Pull-up (BW)": "https://www.youtube.com/shorts/BLX0O9t51oQ",
  "Hand-to-Hand Clean (KB)": "https://www.youtube.com/watch?v=herht-TIRxo",
  "Inverted Row (BW)": "https://www.youtube.com/watch?v=sUTGBQ5NQ-s",
  "Low Pull Snatch (KB)": "https://www.youtube.com/shorts/GK8i2xYGaOM",

  // === Inferno (HIIT) – Lunge (dynamisch) ===
  "Walking Lunge (KB/BW)": "https://www.youtube.com/watch?v=tQNktxPkSeE",
  "Step-back Lunge Hop (BW)": "https://www.youtube.com/shorts/-nok_WaMB_A",
  "Side Lunge Step (KB/BW)": "https://www.youtube.com/shorts/TnOkq6KfHsM",
  "Curtsy Lunge Step (BW)": "https://www.youtube.com/shorts/hr3J9iyP_K0",
  "Skater Lunge (BW)": "https://www.youtube.com/shorts/IkGOdk2VDJw",
  "Forward↔Reverse Lunge Combo": "https://www.youtube.com/shorts/HDfT6w6IUdo",

  // === Inferno (HIIT) – Rotation ===
  "Rotational Swing (KB)": "https://www.youtube.com/shorts/gxmlcxiSpTA",
  "Rotational Clean (KB)": "https://www.youtube.com/watch?v=B4jpuREQ5oo",
  "Russian Twist (KB)": "https://www.youtube.com/watch?v=Tau0hsW8iR0",
  "Figure 8 (KB, hand-to-hand)": "https://www.youtube.com/shorts/7g2v3b3TWKg",
  "Half Kneeling Lift (KB)": "https://www.youtube.com/shorts/kA-aBmPHZqQ",
  "Side Plank Reach Under (BW)": "https://www.youtube.com/watch?v=-ruAdV34H54",

  // === Inferno (HIIT) – Anti-rotation ===
  "Tall kneeling Halo (KB)": "https://www.youtube.com/shorts/2-grmRN2SbA",
  "Renegade Row (KB)": "http://youtube.com/watch?v=7l03NoMzGp4",
  "Plank with KB Drag": "https://www.youtube.com/shorts/59fmvrZ64ro",
  "Deadbug KB Hold": "https://www.youtube.com/watch?v=pXcG0IH2Nkg",
  "Side Plank Snatch (KB)": "https://www.youtube.com/watch?v=X33h4J-NKLA",
  "Bear Crawl KB Drag": "https://www.youtube.com/shorts/3zO3nweBayQ",

  // === Inferno (HIIT) – Loaded Carry ===
  "Farmers Walk (2 KB)": "https://www.youtube.com/watch?v=8OtwXwrJizk",
  "Overhead Carry (1–2 KB)": "https://www.youtube.com/watch?v=54POVWkWjEs",
  "Rack Walk (2 KB)": "https://www.youtube.com/shorts/MatPOjMpCK4",
  "Side Bend (1 KB)": "https://www.youtube.com/shorts/Rl_MsU1yI44",
  "Cross Carry (OH + suitcase)": "https://www.youtube.com/watch?v=bqBvsheL9AM",
  "Bear Crawl (BW)": "https://www.youtube.com/watch?v=4d52Y9W2M0g",

  // ♻️ DurabilitySequence drills
  "Hack Squat": "https://www.youtube.com/watch?v=-5uDm0_SkkQ",
  "Jefferson Curl": "https://www.youtube.com/watch?v=nM747P0_OwM",
  "Hockey Deadlift": "https://www.youtube.com/watch?v=zdzF5jjs_Q4",
  "Bretzell (Stretch)": "https://www.youtube.com/watch?v=9f9DaOINp-Q",
  "Bretzel Armbar": "https://www.youtube.com/watch?v=8ZqcKhDR_qE",
  "Arm Bar": "https://www.youtube.com/watch?v=k7qyA5bMYRA",
  "Bent Arm Bar + Press": "https://www.youtube.com/watch?v=SSi_DhIBpaE",
  "Get Up Arm Rotations": "https://www.youtube.com/watch?v=TibXK8FmDj4",
  "Get Up Neck Rotations": "https://www.youtube.com/watch?v=L4vYLrfFE2o",
  "SOS Get Up": "https://www.youtube.com/watch?v=jfS4zZQDpWk",

  "Front Lever (tuck)": "https://www.youtube.com/shorts/km9werLyeEc",
  "Skin the Cat": "https://www.youtube.com/watch?v=QHnpUcVwZOk",
  "Active Hang": "https://www.youtube.com/shorts/ovh75ysyV9w",
  "Passive Hang": "https://www.youtube.com/shorts/9eY15prKcUY",
  "Arm & Leg Movement": "https://www.youtube.com/shorts/GO78ov4HWP4",

  "Bridge Hold": "https://www.youtube.com/watch?v=tSvmWU-0Zo0",
  "Hip Flexor Stretch Overhead Kettlebell": "https://www.youtube.com/shorts/N6tXS3W5CcY",

  // Neck Series (alles in één)
  "Neck Series": "https://www.youtube.com/watch?v=TZXsOQl8CqA",

  // MobilitySequence (overall video)
  "MobilitySequence": "https://www.youtube.com/watch?v=LPOaWhj_0c8"
};

    (function seedVideoLinksOnce(){
      const cur = getVideoLinks();
      let changed = false;
      for (const [name, url] of Object.entries(VIDEO_LINKS_SEED)) {
        if (!cur[name]) { cur[name] = url; changed = true; }
      }
      if (changed) lsSet('video:links', cur);
    })();

    /* ================== Ladder rules (1:1 met Python) ================== */
    const SWING_LADDER_EX = ["One-arm Swing","(Side Stepping) Two-arm Swing","Snatch","High Pull"];
    const EVEN_LADDER_EX  = ["Double Push Press","Double Push Jerk","Double Clean","Double Swing","Double Snatch","Double Front Squat"];
    const TIME_BASED_EX   = ["Overhead Carry","Front Rack Carry","HS-Plank"];
    const HYBRID_EX       = ["Double Clean & Press","Double Clean & Front Squat","Double Snatch & Overhead Walk","Double Clean & Jerk","Double Snatch & Press","Double Front Squat & Push Press"];

    /* ================== Engines ================== */
    function createEngine({ key, patterns, cycleVolumes, sessionsPerCycle=18 }) {
      const saved = lsGet(key, null);
      const eng = {
        key, patterns, cycleVolumes, sessionsPerCycle,
        session_count: (saved && saved.session_count) || 0,
        current_phase: (saved && saved.current_phase) || 1,
        display_cycle_index: (saved && saved.display_cycle_index) || 1,
        exercise_usage_count: (saved && saved.exercise_usage_count) || {},
        last_session_exercises: (saved && saved.last_session_exercises) || [],
        last_session_volumes: (saved && saved.last_session_volumes) || {},
        all_sessions: (saved && saved.all_sessions) || [],

        calculate_volume(exercise, volume_type){
          const c = this.current_phase;
          const base = this.cycleVolumes[c][volume_type];

          // (3 Min) Get Up — cycle-based tiny rep counts
          if (exercise === "(3 Min) Get Up") {
            if (volume_type === "low") return c;
            if (volume_type === "medium") return c + 1;
            if (volume_type === "high") return c + 2;
          }

          // Hybrids always low volume
          if (HYBRID_EX.includes(exercise)) {
            return this.cycleVolumes[c]["low"];
          }

          // Time-based (seconds)
          if (TIME_BASED_EX.includes(exercise)) {
            if (c === 1) return ({ low:30,  medium:60,  high:90  })[volume_type];
            if (c === 2) return ({ low:45,  medium:75,  high:105 })[volume_type];
            return           ({ low:60,  medium:90,  high:120 })[volume_type]; // c===3
          }

          // Default reps
          return base;
        },

        get_ladder_pattern(exercise, volume){
          const c = this.current_phase;

          // Time-based
          if (TIME_BASED_EX.includes(exercise)) {
            return [`${volume} sec`, volume];
          }

          // Any Get Up wording → reps
          if (exercise.includes("Get Up")) {
            return [`${volume} reps`, volume];
          }

          // Hybrids — cycle-based ladders (always low volume)
          if (HYBRID_EX.includes(exercise)) {
            if (c === 1) return ["1-2-3-4", 10];
            if (c === 2) return ["1-2-3-4-5", 15];
            return ["2x 1-2-3-4", 20]; // c===3
          }

          // Swing/asymmetric ladders
          if (SWING_LADDER_EX.includes(exercise)) {
            if (c === 1) {
              if (volume === 10) return ["10", 10];
              if (volume === 20) return ["5-15", 20];
              if (volume === 30) return ["5-10-15", 30];
            } else if (c === 2) {
              if (volume === 15) return ["5-10", 15];
              if (volume === 25) return ["10-15", 25];
              if (volume === 40) return ["5-15-20", 40];
            } else { // c===3
              if (volume === 20) return ["5-15", 20];
              if (volume === 30) return ["10-20", 30];
              if (volume === 50) return ["5-10-15-20", 50];
            }
          }

          // Even ladders
          if (EVEN_LADDER_EX.includes(exercise)) {
            if (c === 1) {
              if (volume === 10) return ["4-6", 10];
              if (volume === 20) return ["2-4-6-8", 20];
              if (volume === 30) return ["2-4-6-8-10", 30];
            } else if (c === 2) {
              if (volume === 15) return ["2-4-6 + 1-2", 15];
              if (volume === 25) return ["2x 2-4-6 + 1", 25];
              if (volume === 40) return ["2-4-6-8-10 + 4-6", 40];
            } else { // c===3
              if (volume === 20) return ["2-4-6-8", 20];
              if (volume === 30) return ["2-4-6-8-10", 30];
              if (volume === 50) return ["2x 2-4-6-8 + 2-4", 50];
            }
          }

          // Default ladders
          if (c === 1) {
            if (volume === 10) return ["1-2-3-4", 10];
            if (volume === 20) return ["2x 1-2-3-4", 20];
            if (volume === 30) return ["3x 1-2-3-4", 30];
          } else if (c === 2) {
            if (volume === 15) return ["1-2-3-4-5", 15];
            if (volume === 25) return ["1-2-3-4-5 + 1-2-3-4", 25];
            if (volume === 40) return ["2x 1-2-3-4-5 + 1-2-3-4", 40];
          } else { // c===3
            if (volume === 20) return ["2x 2-3-5", 20];
            if (volume === 30) return ["3x 2-3-5", 30];
            if (volume === 50) return ["2x 2-3-5-10 + 2-3-5", 50];
          }

          return [`${volume} reps`, volume];
        },

        get_volume_format(exercise, volume){
          const [ladder, total] = this.get_ladder_pattern(exercise, volume);

          // Time-based already shows "<sec> sec"
          if (TIME_BASED_EX.includes(exercise)) return ladder;

          if (ladder === `${total} reps` || ladder === `${total} rep(s)`) return `${total} reps`;
          return `${total} reps (${ladder})`;
        },

        select_exercise_for_pattern(pattern){
          const list=this.patterns[pattern].slice();
          const pool=list.filter(ex=>this.last_session_exercises.indexOf(ex)===-1);
          const candidates=pool.length?pool:list;
          const useCount=(ex)=>this.exercise_usage_count[ex]||0;
          let minUse=useCount(candidates[0]);
          for(let i=1;i<candidates.length;i++){ const u=useCount(candidates[i]); if(u<minUse)minUse=u; }
          const least=candidates.filter(ex=> (this.exercise_usage_count[ex]||0)===minUse );
          return least[Math.floor(Math.random()*least.length)];
        },

        select_volume_type(pattern, exercise, current_session_volumes){
          // Hybrids always low
          if (HYBRID_EX.includes(exercise)) return 'low';

          const vals=[]; for(const k in current_session_volumes){ vals.push(current_session_volumes[k]); }
          const highAlready = vals.indexOf('high')>-1;

          const entries = this.all_sessions.filter(s => s.phase===this.current_phase && s.exercise===exercise);
          let lowC=0, medC=0, highC=0;
          for(let i=0;i<entries.length;i++){
            const vt=entries[i].volume_type;
            if(vt==='low')lowC++; else if(vt==='medium')medC++; else if(vt==='high')highC++;
          }
          const valid=[];
          if(medC<3) valid.push('medium');
          if(lowC<2) valid.push('low');
          if(highC<1 && !highAlready) valid.push('high');
          const avoid=this.last_session_volumes ? this.last_session_volumes[pattern] : null;
          let choices = valid.length ? valid : (highAlready ? ['low','medium'] : ['low','medium','high']);
          if(avoid && choices.length>1) choices = choices.filter(t=>t!==avoid);
          return choices[Math.floor(Math.random()*choices.length)];
        },

        generate_single_session(){
          const session_number=(this.session_count%this.sessionsPerCycle)+1;
          const session_exercises=[]; const current_session_volumes={};
          const pattern_order=Object.keys(this.patterns).sort(()=>Math.random()-0.5);

          for(const pattern of pattern_order){
            const exercise=this.select_exercise_for_pattern(pattern);
            const volume_type=this.select_volume_type(pattern,exercise,current_session_volumes);
            const volume=this.calculate_volume(exercise,volume_type);
            const formatted_volume=this.get_volume_format(exercise,volume);
            session_exercises.push({
              session:session_number, pattern, exercise, volume_type, volume,
              formatted_volume, order:session_exercises.length+1, phase:this.current_phase, display_cycle:this.display_cycle_index
            });
            this.exercise_usage_count[exercise]=(this.exercise_usage_count[exercise]||0)+1;
            current_session_volumes[pattern]=volume_type;
          }

          this.last_session_exercises=session_exercises.map(r=>r.exercise);
          this.last_session_volumes=current_session_volumes;
          Array.prototype.push.apply(this.all_sessions, session_exercises);
          this.session_count+=1;

          const main=session_exercises.map(b=>`${b.pattern.replace(/ (Pattern|Category)$/,'')}: ${b.exercise} — ${b.formatted_volume}`);
          this.persist();
          return { main, meta:{ modality:null, cycle:this.display_cycle_index, phase:this.current_phase, session:session_number, phase_end:(session_number===this.sessionsPerCycle) } };
        },

        persist(){
          lsSet(this.key,{
            session_count:this.session_count, current_phase:this.current_phase,
            display_cycle_index:this.display_cycle_index, exercise_usage_count:this.exercise_usage_count,
            last_session_exercises:this.last_session_exercises, last_session_volumes:this.last_session_volumes,
            all_sessions:this.all_sessions
          });
        },
        hardResetToStart(){
          this.display_cycle_index=1; this.current_phase=1; this.session_count=0;
          this.exercise_usage_count={}; this.last_session_exercises=[]; this.last_session_volumes={}; this.all_sessions=[];
          this.persist();
        },
        startNewCycle(){
          this.display_cycle_index=(this.display_cycle_index||1)+1;
          this.current_phase=1; this.session_count=0; this.exercise_usage_count={}; this.last_session_exercises=[]; this.last_session_volumes={}; this.all_sessions=[];
          this.persist();
        }
      };
      return eng;
    }

    // Engines
    const KETTLEBELLENGINE = createEngine({
      key:'everstrong:KettlebellEngine:v1',
      patterns:{
        "Swing Pattern": ["One-Legged Deadlift","Double Sumo Deadlift","Single Leg Glute Bridge","One-arm Swing","(Side Stepping) Two-arm Swing","Double Swing"],
        "Get Up Pattern": ["(3 Min) Get Up","Supine to Sit Up","Windmill","Bent Press","Supine to Half Kneel","Half Kneel to Stand"],
        "Clean Pattern": ["HS-Plank","Front Rack Carry","Single Dead Clean","Double Clean","Pullover","One-arm Row"],
        "Squat Pattern": ["B-stance Goblet Squat","Single Front Squat","Paused Front Squat","Double Front Squat","Athletic Lunge","Bottom Up Squat"],
        "Press Pattern": ["Military Press","Top Down Press","Half Kneeling Press","Floor Press","Double Push Press","Double Push Jerk"],
        "Snatch Pattern": ["Overhead Carry","Snatch","Low Pull Snatch","High Pull","Front/Side Raise Snatch","Double Snatch"],
        "Hybrid Pattern": ["Double Clean & Press","Double Clean & Front Squat","Double Snatch & Overhead Walk","Double Clean & Jerk","Double Snatch & Press","Double Front Squat & Push Press"]
      },
      cycleVolumes:{1:{low:10,medium:20,high:30},2:{low:15,medium:25,high:40},3:{low:20,medium:30,high:50}},
      sessionsPerCycle:36
    });
    const BARBELLENGINE = createEngine({
      key:'everstrong:BarbellEngine:v2',
      patterns:{
        "Leg Pattern":["Back Squat","Front Squat","Zercher Squat"],
        "Push Pattern":["Bench Press","Incline Bench Press","Shoulder Press"],
        "Pull Pattern":["Conventional Deadlift","Goodmorning","Sumo Deadlift"]
      },
      cycleVolumes:{1:{low:10,medium:20,high:30},2:{low:15,medium:25,high:40},3:{low:20,medium:30,high:50}},
      sessionsPerCycle:18
    });
    const BODYWEIGHTENGINE = createEngine({
      key:'everstrong:BodyweightEngine:v1',
      patterns:{
        "Leg Category":["Box Pistol","Top Down Pistol","Full Pistol"],
        "Push Category":["One-arm One-leg Push Up","Wall HSPU (assist)","Dips"],
        "Pull Category":["Tactical Pull Up","Hanging Leg Raise","Front Lever (prog)"]
      },
      cycleVolumes:{1:{low:10,medium:20,high:30},2:{low:15,medium:25,high:40},3:{low:20,medium:30,high:50}},
      sessionsPerCycle:18
    });

    /* ============== Inferno (HIIT) ============== */
(function(){
  // 8 patronen, 6 oefeningen elk — KB + BW only
  // SU ~ relatieve stimulus; generator kiest 30–70 SU per item en rekent reps = SU / stim
  const db = {
  // === Squat (statisch / op de plek) ===
  squat: [
    { name:"Jump Squat (BW)",             stim:1.2, uni:false },
    { name:"Split Squat Jump (BW)",       stim:1.3, uni:false },
    { name:"Cossack Squat (KB)",          stim:1.4, uni:false },
    { name:"Goblet Thruster (KB)",        stim:1.6, uni:false },
    { name:"Box Jump (BW)",               stim:1.5, uni:false },
    { name:"Box Step Over (KB)",          stim:1.4, uni:false }
  ],

  // === Hinge ===
  hinge: [
    { name:"One-arm Swing (KB)",          stim:1.2, uni:true  },
    { name:"Hand-to-Hand Swing (KB)",     stim:1.3, uni:true  },
    { name:"Broad Jump (BW)",             stim:1.0, uni:false },
    { name:"Two-arm Swing (KB)",          stim:1.1, uni:false },
    { name:"Snatch (KB)",                 stim:1.7, uni:true  }, // 1-arm snatch
    { name:"Deadlift Jump (KB)",          stim:1.1, uni:false }
  ],

  // === Push ===
  push: [
    { name:"Plyo Push-up (BW)",           stim:1.2, uni:false },
    { name:"Push Press (KB)",             stim:1.6, uni:true  },
    { name:"Push Jerk (KB)",              stim:1.8, uni:true  },
    { name:"Clean & Push Press (BW)",     stim:1.2, uni:false },
    { name:"Dips (BW)",                   stim:1.2, uni:false },
    { name:"Viking Push Press (KB)",      stim:1.7, uni:true  }
  ],

  // === Pull ===
  pull: [
    { name:"High Pull (KB)",              stim:1.4, uni:true  },
    { name:"Explosive Row (KB)",          stim:1.3, uni:true  },
    { name:"Jumping Pull-up (BW)",        stim:1.5, uni:false },
    { name:"Hand-to-Hand Clean (KB)",     stim:1.6, uni:true  },
    { name:"Inverted Row (BW)",           stim:1.1, uni:false },
    { name:"Low Pull Snatch (KB)",        stim:1.4, uni:true  }
  ],

  // === Lunge (dynamisch / stappen) ===
  lunge: [
    { name:"Walking Lunge (KB/BW)",       stim:1.5, uni:true  },
    { name:"Step-back Lunge Hop (BW)",    stim:1.1, uni:true  },
    { name:"Side Lunge Step (KB/BW)",     stim:1.3, uni:true  },
    { name:"Curtsy Lunge Step (BW)",      stim:1.4, uni:true  },
    { name:"Skater Lunge (BW hop)",       stim:1.2, uni:true  },
    { name:"Forward↔Reverse Lunge Combo", stim:1.5, uni:true  }
  ],

  // === Rotation ===
  rotation: [
    { name:"Rotational Swing (KB)",       stim:1.6, uni:true  },
    { name:"Rotational Clean (KB)",       stim:1.8, uni:true  },
    { name:"Russian Twist (KB)",          stim:0.8, uni:false },
    { name:"Figure 8 (KB, hand-to-hand)", stim:1.3, uni:true  },
    { name:"Half Kneeling Lift (KB)",     stim:1.5, uni:true  },
    { name:"Side Plank Reach Under (BW)", stim:1.2, uni:true  }
  ],

  // === Anti-rotation ===
  antirotation: [
    { name:"Tall kneeling Halo (KB)",     stim:1.0, uni:false },
    { name:"Renegade Row (KB)",           stim:1.3, uni:true  },
    { name:"Plank with KB Drag",          stim:1.3, uni:true  },
    { name:"Deadbug KB Hold",             stim:0.8, uni:false },
    { name:"Side Plank Snatch (KB)",      stim:1.6, uni:true  },
    { name:"Bear Crawl KB Drag",          stim:1.4, uni:true  }
  ],

  // === Loaded Carry / bracing locomotion ===
  carry: [
    { name:"Farmers Walk (2 KB)",         stim:1.8, uni:false },
    { name:"Overhead Carry (1–2 KB)",     stim:2.0, uni:true  },
    { name:"Rack Walk (2 KB)",            stim:1.6, uni:false },
    { name:"Side Bend (1 KB)",            stim:1.2, uni:true  },
    { name:"Cross Carry (OH + suitcase)", stim:2.2, uni:true  },
    { name:"Bear Crawl (BW)",             stim:1.1, uni:false }
  ]
};


  // helpers (laat deze staan als je ooit het db wijzigt)
  function r(min,max){ return Math.floor(Math.random()*(max-min+1))+min; }
  function pick(a){ return a[Math.floor(Math.random()*a.length)]; }
  function shuffle(a){ const x=a.slice(); for(let i=x.length-1;i>0;i--){ const j=Math.floor(Math.random()*(i+1)); [x[i],x[j]]=[x[j],x[i]]; } return x; }
  function fmt(ex, su){
    const reps = Math.max(1, Math.round(su / ex.stim));
    const perArm = ex.uni ? ` (${Math.ceil(reps/2)} per arm)` : "";
    return `${ex.name} — ${reps} reps${perArm} (${su} SU)`;
  }

  function build(targetSU){
    const pats = Object.keys(db);
    const maxPerPat = 2; // nooit meer dan 2 oefeningen per patroon
    let curSU = 0;
    const used = Object.fromEntries(pats.map(p=>[p,0]));
    const out = [];

    // 1 ronde langs alle patronen voor breedte
    for(const p of pats){
      const ex = pick(db[p]);
      const su = r(30,70);
      curSU += su; used[p] += 1;
      out.push(fmt(ex, su));
    }

    // daarna aanvullen tot target binnen marge
    let guard = 0;
    while(curSU < targetSU - 30 && guard < 1000){
      guard++;
      const p = pick(pats);
      if(used[p] >= maxPerPat) continue;
      const ex = pick(db[p]);
      const su = r(30,70);
      if(curSU + su > targetSU + 10) break;
      curSU += su; used[p] += 1;
      out.push(fmt(ex, su));
    }

    return shuffle(out);
  }

  // publieks-API
  window.HELLFIRE_GENERATE = function(target){
    const allowed = [300,400,500];
    if(!allowed.includes(target)){
      target = allowed.reduce((best, cur)=> Math.abs(cur-target)<Math.abs(best-target) ? cur : best, allowed[0]);
    }
    return { lines: build(target), su: target };
  };
})();

    /* ======= Rest/Breathing ======= */
    const REST_BREATHING_OPTIONS = [
      { level:"Beginner", name:"Bottom Triangle 4-4-4", pattern:"Inhale 4s • Exhale 4s • Hold 4s (bottom)", note:"Practice 5–20 minutes." },
      { level:"Intermediate", name:"Bottom Triangle 4-6-8", pattern:"Inhale 4s • Exhale 6s • Hold 8s (bottom)", note:"Practice 5–20 minutes." },
      { level:"Advanced", name:"Bottom Triangle 6-8-12", pattern:"Inhale 6s • Exhale 8s • Hold 12s (bottom)", note:"Practice 5–20 minutes." }
    ];
/* ======= Breathing builder ======= */
function buildBreathingSession(minutes=10, level="Beginner"){
  const opt = REST_BREATHING_OPTIONS.find(o => o.level === level) || REST_BREATHING_OPTIONS[0];
  const lines = [
    `Breathing — ${opt.name} • ${minutes} min`,
    "",
    `Pattern: ${opt.pattern}`,
    opt.note
  ];
  return { main: lines, meta: { modality: "breathing", minutes, level, date: new Date().toISOString() } };
}
    /* ======= UI helpers: list renderer ======= */
    function renderSmartList(lines){
      const out=[]; let buffer=[];
      function flushList(){
        if(buffer.length){
          out.push(
            <ul className="list-disc ml-6 space-y-1" key={"ul-"+out.length}>
              {buffer.map((t,i)=>(<li key={i}>{t}</li>))}
            </ul>
          );
          buffer=[];
        }
      }
      lines.forEach((raw, idx)=>{
        const line = (raw==null) ? "" : String(raw);
        if(line.trim()===""){
          flushList();
          out.push(<div key={"sp-"+idx} className="h-2" />);
          return;
        }
        if(line.startsWith("* ")){
          buffer.push(line.slice(2));
        } else {
          flushList();
          out.push(<p key={"p-"+idx} className="font-medium mt-3">{line}</p>);
        }
      });
      flushList();
      return out;
    }

    /* ========= Calm UI components ========= */
    function AppShell({ activeTab, setActiveTab, children, onToggleDark, calm, setCalm, recoveryMode, setRecoveryMode, recoveryCount, REC_MAX }) {
      const tabs = [
        { id: "train", label: "Train" },
        { id: "recovery", label: "Recovery" },
        { id: "history", label: "History" },
        { id: "export", label: "Export" },
        { id: "settings", label: "Settings" },
      ];
      return (
        <div className="mx-auto max-w-2xl px-3">
          {/* Topbar */}
          <div className="sticky top-0 z-20 backdrop-blur bg-white/70 dark:bg-gray-900/60 border-b border-black/10 dark:border-white/10">
            <div className="flex items-center justify-between h-12">
              <div className="flex items-center gap-2">
                <button
                  className="p-2 rounded-lg hover:bg-black/5 dark:hover:bg:white/5 md:hidden"
                  onClick={()=>document.getElementById("drawer").showModal()}
                  aria-label="Open menu"
                >
                  <svg width="22" height="22" viewBox="0 0 24 24" className="opacity-70"><path fill="currentColor" d="M3 6h18v2H3zm0 5h18v2H3zm0 5h18v2H3z"/></svg>
                </button>
                <h1 className="font-semibold">EverStrong</h1>
              </div>
              <div className="flex items-center gap-3">
                <label className="text-xs flex items-center gap-1 opacity-80">
                  <input type="checkbox" checked={calm} onChange={(e)=>{ setCalm(e.target.checked); lsSet('ui:calm', e.target.checked); }} />
                  Calm
                </label>
                <button onClick={onToggleDark} className="text-xs underline opacity-80">Dark</button>
              </div>
            </div>
            {/* Tabs desktop */}
            <div className="hidden md:flex gap-1 pb-2">
              {tabs.map(t=>(
                <button
                  key={t.id}
                  className={`px-3 py-1.5 rounded-lg text-sm transition ${
                    activeTab===t.id
                    ? "bg-blue-600 text-white"
                    : "hover:bg-black/5 dark:hover:bg:white/5"
                  }`}
                  onClick={()=>{ setActiveTab(t.id); lsSet('ui:tab', t.id); }}
                >
                  {t.label}
                </button>
              ))}
            </div>
          </div>

          {/* Drawer (mobile) */}
          <dialog id="drawer" className="rounded-lg p-0 w-72 bg-white dark:bg-gray-900 border border-black/10 dark:border-white/10">
            <div className="p-3 border-b border-black/10 dark:border-white/10 flex items-center justify-between">
              <span className="font-semibold">Menu</span>
              <button onClick={()=>document.getElementById("drawer").close()} className="p-1 rounded hover:bg-black/5 dark:hover:bg:white/5">✕</button>
            </div>
            <div className="p-2">
              {tabs.map(t=>(
                <button
                  key={t.id}
                  className={`w-full text-left px-3 py-2 rounded-lg text-sm mb-1 ${
                    activeTab===t.id
                    ? "bg-blue-600 text-white"
                    : "hover:bg-black/5 dark:hover:bg:white/5"
                  }`}
                  onClick={()=>{ setActiveTab(t.id); lsSet('ui:tab', t.id); document.getElementById("drawer").close(); }}
                >
                  {t.label}
                </button>
              ))}
            </div>
          </dialog>

          {/* Page content */}
          <div className="mt-3 space-y-3">
            <div className="flex items-center gap-2 text-xs text-gray-500 dark:text-gray-400">
              <span className="pill">Recovery today: {recoveryCount}/{REC_MAX}</span>
              <button
                onClick={()=>setRecoveryMode(m=> m==="gate" ? "inline" : "gate")}
                className="underline"
                title="Toggle recovery gate/inline"
              >
                Recovery mode: {recoveryMode === "gate" ? "Gate" : "Inline"}
              </button>
            </div>
            {children}
          </div>
        </div>
      );
    }

    function Accordion({ title, children, defaultOpen=false }) {
      const [open, setOpen] = React.useState(defaultOpen);
      return (
        <div className="border border-black/10 dark:border-white/10 rounded-xl">
          <button
            onClick={()=>setOpen(o=>!o)}
            className="w-full flex items-center justify-between px-3 py-2"
          >
            <span className="font-medium">{title}</span>
            <span className="text-sm opacity-70">{open ? "−" : "+"}</span>
          </button>
          {open && <div className="px-3 pb-3">{children}</div>}
        </div>
      );
    }

    function CalmCard({ title, subtitle, children, footer }) {
      return (
        <section className="rounded-xl border border-black/10 dark:border-white/10">
          {(title || subtitle) && (
            <div className="px-3 pt-3">
              {title && <h2 className="text-lg font-semibold">{title}</h2>}
              {subtitle && <p className="text-xs text-gray-500 dark:text-gray-400 mt-0.5">{subtitle}</p>}
            </div>
          )}
          <div className="px-3 py-3">
            {children}
          </div>
          {footer && <div className="px-3 pb-3">{footer}</div>}
        </section>
      );
    }

    /* ======= Exercise Card (met klikbare YouTube-thumbnail) ======= */
function ExerciseCard({ line }) {
  const raw = String(line);
  let name = "", pattern = "", details = "";

  // Format met "—":  "Pattern: Naam — details" of "Naam — details"
  if (raw.includes("—")) {
    const [left, ...rest] = raw.split("—");
    details = rest.join("—").trim();
    const colon = left.split(":");
    if (colon.length >= 2) {
      pattern = colon[0].replace(/^\*\s*/,"").trim();
      name = colon.slice(1).join(":").trim();
    } else {
      name = left.replace(/^\*\s*/,"").trim();
    }
  } else {
    // Alleen naam (zoals "Hack Squat")
    name = raw.replace(/^\*\s*/,"").trim();
  }

  if (!name) return <p className="">{line}</p>;


      const [open, setOpen] = React.useState(false);
      const [url, setUrl] = React.useState(getVideoLinks()[name] || "");

      const title = pattern ? `${pattern}: ${name} — ${details}` : `${name} — ${details}`;

      const ytId = getYouTubeId(url);
      const thumb = ytId ? getYouTubeThumb(ytId, 'mq') : null;

      return (
        <section className="rounded-xl border border-black/10 dark:border-white/10">
          <button
            onClick={()=>setOpen(o=>!o)}
            className="w-full flex items-center justify-between px-3 py-2"
          >
            <span className="font-medium">{title}</span>
            <span className="text-sm opacity-70">{open ? "−" : "+"}</span>
          </button>

          {open && (
            <div className="px-3 pb-3 space-y-3">
              <div className="flex items-start gap-3">
                {thumb ? (
                  <button
                    className="relative rounded-lg overflow-hidden shrink-0"
                    onClick={()=>window.open(url, "_blank", "noopener,noreferrer")}
                    title="Open video"
                  >
                    <img
                      src={thumb}
                      alt={`${name} demo`}
                      className="w-40 h-24 object-cover"
                      loading="lazy"
                      referrerPolicy="no-referrer"
                    />
                    <span className="absolute inset-0 grid place-items-center">
                      <span className="bg-black/40 rounded-full p-2">
                        <svg width="18" height="18" viewBox="0 0 24 24" className="text-white">
                          <path fill="currentColor" d="M8 5v14l11-7z"/>
                        </svg>
                      </span>
                    </span>
                  </button>
                ) : (
                  <div className="w-40 h-24 rounded-lg grid place-items-center bg-gray-200 dark:bg-gray-800 text-xs text-gray-500">
                    Geen thumbnail
                  </div>
                )}

                <div className="flex-1 space-y-2">
                  <div className="flex flex-col sm:flex-row gap-2">
                    <input
                      className="w-full rounded px-2 py-1 bg-white dark:bg-gray-800 border border-black/10 dark:border-white/10"
                      placeholder="https://www.youtube.com/watch?v=..."
                      value={url}
                      onChange={(e)=>setUrl(e.target.value)}
                      onBlur={()=>saveVideoLink(name, url.trim())}
                    />
                    <button
                      className="btn-sm bg-blue-600"
                      onClick={()=>{
                        if(!url) return;
                        saveVideoLink(name, url.trim());
                        window.open(url, "_blank", "noopener,noreferrer");
                      }}
                      disabled={!url}
                      title={url ? "Open video in nieuw tabblad" : "Voeg eerst een link toe"}
                    >
                      Bekijk demo
                    </button>
                    {url && (
                      <button
                        className="btn-sm bg-gray-700"
                        onClick={()=>{ setUrl(""); saveVideoLink(name, ""); }}
                        title="Link verwijderen"
                      >
                        Verwijder link
                      </button>
                    )}
                  </div>
                  {!url && <p className="text-xs text-gray-500 dark:text-gray-400">Plak een YouTube-URL voor een klikbare thumbnail. Ondersteunt <code>watch?v=</code>, <code>youtu.be</code>, <code>shorts</code> en <code>embed</code>.</p>}
                </div>
              </div>
<LastLoadTracker name={name} open={open} />d
            </div>
          )}
        </section>
      );
    }

    /* ======= Session rendering (met kaarten in Train) ======= */
    function Timer({ elapsed, setElapsed, running, setRunning }) {
      const ref=useRef(null);
      useEffect(()=>{
        if(running){ ref.current=setInterval(()=>setElapsed(t=>t+1),1000); }
        else if(ref.current){ clearInterval(ref.current); ref.current=null; }
        return ()=>{ if(ref.current){ clearInterval(ref.current); ref.current=null; } };
      },[running,setElapsed]);
      return (
        <div>
          <p className="text-xl font-mono text-center">{fmtHMS(elapsed)}</p>
          <div className="flex gap-2 mt-2">
            <button className="btn bg-green-600 w-full" onClick={()=>setRunning(true)}>Start</button>
            <button className="btn bg-yellow-500 text-black w-full" onClick={()=>setRunning(false)}>Stop</button>
            <button className="btn bg-gray-600 w-full" onClick={()=>{ setElapsed(0); setRunning(false); }}>Reset</button>
          </div>
        </div>
      );
    }

    function SessionView({ session }) {
      if(!session) return null;
      const m=session.meta||{};
      const isHIIT = m.modality==='hiit';
      const isRecovery = m.modality==='recovery';
      const isBreathing = m.modality==='breathing';
      const isWarmup = m.modality==='warmup';
      const isStrength = ['kettlebell','barbell','bodyweight'].includes(m.modality);
      const allowExerciseCards = isHIIT || isStrength || isRecovery;

      const title = isHIIT
        ? `Inferno${m.su?` • ${m.su} SU`:''}${m.date ? ` • ${new Date(m.date).toLocaleDateString()}` : ''}`
        : isRecovery
          ? `Active Recovery${m.choice?` • ${m.choice}`:''}`
          : isBreathing
            ? `Breathing${m.minutes?` • ${m.minutes} min`:''}${m.date?` • ${new Date(m.date).toLocaleDateString()}`:''}`
            : isWarmup
              ? `Warm-up`
              : (m.cycle && m.phase && m.session) ? `${(m.modality||'Session')[0].toUpperCase()}${(m.modality||'session').slice(1)} ${m.cycle}.${m.phase}.${m.session}` : `Today's Session`;

      const lines = session.main || [];

      return (
        <div>
          <h3 className="font-semibold mb-2 text-base">{title}</h3>
{/* Quick demo button for overall Recovery choices (MobilitySequence / Neck Series) */}
{isRecovery && session?.meta?.choice && (() => {
  const map = getVideoLinks();
  const url = map[session.meta.choice];
  return url ? (
    <div className="mt-2">
      <button
        className="btn-sm bg-blue-600"
        onClick={()=>window.open(url, "_blank", "noopener,noreferrer")}
        title="Open demo video"
      >
        Follow Along Session — {session.meta.choice}
      </button>
    </div>
  ) : null;
})()}
<div className="space-y-2">
  {(() => {
    let skipNext = false; // sla de volgende regel over als we gecombineerd hebben

    return (session.main || []).map((raw, idx) => {
      if (skipNext) { skipNext = false; return null; }

      const line = (raw == null) ? "" : String(raw).trim();
      if (line === "") return <div key={"sp-"+idx} className="h-2" />;

      // ---------- 1) Recovery: combineer alléén met pure doseregel ----------
      // Voorbeeld dat WEL combineert: "Hack Squat" + "* 2×5–8"  -> "Hack Squat — 2×5–8"
      // Voorbeeld dat NIET combineert: "Hanging Series" + "* Front Lever (tuck) — …"
      if (!line.includes("—") && (isRecovery && allowExerciseCards)) {
        const nextRaw = (session.main || [])[idx+1];
        const next = nextRaw ? String(nextRaw).trim() : "";
        const nextIsDose = /^\*\s*\d/.test(next); // bullet die met een cijfer begint

        if (nextIsDose) {
          const combined = `${line} — ${next.replace(/^\*\s*/, "")}`;
          skipNext = true; // volgende bullet overslaan
          return <ExerciseCard key={"ex-"+idx} line={combined} />;
        }
      }

      // ---------- 2) Bullets ----------
      if (line.startsWith("* ")) {
        const rest = line.slice(2).trim();

        if (isRecovery && allowExerciseCards) {
          // Bullets die een oefening + details bevatten (met '—') renderen we als kaart
          // Voorbeeld: "* Bridge Hold — 2×10–20 sec"  -> kaart met video
          if (rest.includes("—")) {
            return <ExerciseCard key={"ex-"+idx} line={rest} />;
          }
        }

        // Overige bullets blijven bullets
        return <ul key={"ul-"+idx} className="list-disc ml-6"><li>{rest}</li></ul>;
      }

      // ---------- 3) Kaarten voor HIIT/Strength zoals voorheen; Recovery-kaarten als er '—' in staat ----------
      if (allowExerciseCards && (line.includes("—") || (isRecovery && /\d/.test(line)))) {
        return <ExerciseCard key={"ex-"+idx} line={line} />;
      }

      // ---------- 4) Default: paragraaf (kopjes/intro) ----------
      return <p key={"p-"+idx} className="font-medium mt-3">{line}</p>;
    });
  })()}
</div>

          <p className="text-xs text-gray-400 mt-2">Pinned until you press “Complete”.</p>
        </div>
      );
    }

    function History({ modality }) {
      const key=`history:${modality}`;
      const [items,setItems]=useState(lsGet(key,[]));
      const [open,setOpen]=useState(false);
      useEffect(()=>{ setItems(lsGet(key,[])); },[modality,open]);
      if(!items || items.length===0) return <div className="mb-1 text-sm text-gray-400">History (empty)</div>;
      const sorted=[...items].sort((a,b)=> new Date(b.saved_at) - new Date(a.saved_at));
      return (
        <div>
          <button className="text-sm underline" onClick={()=>setOpen(o=>!o)}>{open?'Hide History':`Show History (${items.length})`}</button>
          {open && (
            <div className="mt-2 space-y-2">
              {sorted.map((h,idx)=>(
                <div key={idx} className="p-3 rounded-xl border border-black/10 dark:border-white/10">
                  <div className="text-sm flex flex-wrap gap-3">
                    <span className="font-medium">{(h.meta&&h.meta.modality||'').toUpperCase()}</span>
                    {h.meta&&h.meta.choice && <span>• {h.meta.choice}</span>}
                    {h.meta&&h.meta.cycle!=null&&h.meta.session!=null && <span>• {h.meta.cycle}.{h.meta.phase}.{h.meta.session}</span>}
                    {h.meta && h.meta.date && <span>• {new Date(h.meta.date).toLocaleString()}</span>}
                    <span>• {new Date(h.saved_at).toLocaleString()}</span>
                    {h.timer_seconds>0 && <span>• Time: {fmtHMS(h.timer_seconds)}</span>}
                    {h.meta&&h.meta.su && <span>• {h.meta.su} SU</span>}
                  </div>
                  <div className="text-sm mt-1">
                    {renderSmartList(h.main || [])}
                  </div>
                </div>
              ))}
            </div>
          )}
        </div>
      );
    }

    /* ======= Tests KB/BB/BW ======= */
    const BB_REVIEW_NOTE = "If you successfully completed all prescribed reps and sets for all barbell lifts in this phase, you can increase Upper body +2.5–5% and Lower body +5–10% and start a new cycle with the heavier weight. Or continue the same cycle with the current weights and higher volume.";
    const BB_REVIEW_ITEMS = [
      { id:"legs", label:"Lower Body — All prescribed sets & reps completed across the phase with solid form (no missed reps / no grinders above RPE 9.5)." },
      { id:"push", label:"Upper Body Push — All prescribed sets & reps completed across the phase with solid form." },
      { id:"pull", label:"Upper Body Pull — All prescribed sets & reps completed across the phase with solid form." }
    ];
    const KB_TEST_ITEMS = [
      { k: "One-arm Swing", note: "10 reps each arm" },
      { k: "Get Up",        note: "1 rep each arm" },
      { k: "Double Clean",  note: "5 reps" },
      { k: "Military Press",note: "5 reps each arm" },
      { k: "Double Front Squat", note: "5 reps" },
      { k: "Snatch",        note: "5 reps each arm" }
    ];
    const BW_REVIEW_NOTE =
      "If you successfully completed all prescribed reps and sets for all bodyweight movements in this phase, you can progress to the next cycle with harder variations (or higher volume). Or repeat the same cycle if you struggled.";
    const BW_REVIEW_ITEMS = [
      { id:"legs", label:"Legs — All prescribed sets & reps completed with strict form (no compensations, no breakdown)." },
      { id:"push", label:"Upper Body Push — All prescribed sets & reps completed with solid form (no sagging / no missed reps)." },
      { id:"pull", label:"Upper Body Pull — All prescribed sets & reps completed with full ROM and control (no kipping / no partial reps)." }
    ];

    function buildKbTestSession(){
      const lines = [
        "Kettlebell Test Day — Use one bell heavier than your normal bell for Test Day.",
        "",
        ...KB_TEST_ITEMS.map(it => `* ${it.k}${it.note ? " — "+it.note : ""}`)
      ];
      return { main: lines, meta: { modality: "kettlebell_test", date: new Date().toISOString() } };
    }
    function buildBbReviewSession(){
      const lines = [
        "Barbell Phase Review (Not a max test)",
        "",
        "* " + BB_REVIEW_NOTE,
      ];
      return { main: lines, meta: { modality: "barbell_test", date: new Date().toISOString() } };
    }
    function buildBwReviewSession(){
      const lines = [
        "Bodyweight Phase Review (Not a max test)",
        "",
        "* " + BW_REVIEW_NOTE
      ];
      return { main: lines, meta: { modality: "bodyweight_test", date: new Date().toISOString() } };
    }

    function TestView({ modality, onSubmit, testChecks, setTestChecks, testPassed, onStartNewCycle, onContinueCycle }) {
      const isKB = modality === 'kettlebell';
      const isBB = modality === 'barbell';
      const isBW = modality === 'bodyweight';
      const items = isKB ? KB_TEST_ITEMS : isBB ? BB_REVIEW_ITEMS : BW_REVIEW_ITEMS;

      return (
        <div>
          <h2 className="font-semibold mb-2 text-lg">
            {isKB ? "Kettlebell Test Day" : isBB ? "Barbell Phase Review" : "Bodyweight Phase Review"}
          </h2>
          {isKB ? (
            <p className="text-sm mb-2"><strong>Important:</strong> Use one bell heavier than your normal bell for Test Day.</p>
          ) : (
            <div className="text-sm mb-2">
              <p>{isBB ? BB_REVIEW_NOTE : BW_REVIEW_NOTE}</p>
            </div>
          )}
          <div className="space-y-2">
            {items.map((it, idx) => {
              const key = isKB ? it.k : it.id;
              const label = isKB ? `${it.k}${it.note?` — ${it.note}`:''}` : it.label;
              return (
                <label key={idx} className="flex items-start justify-between gap-3">
                  <span className="text-base flex-1">{label}</span>
                  <input
                    type="checkbox"
                    checked={!!testChecks[key]}
                    onChange={() => setTestChecks(t => ({ ...t, [key]: !t[key] }))}
                    className="mt-1"
                  />
                </label>
              );
            })}
          </div>
          {!testPassed ? (
            <button onClick={onSubmit} className="btn bg-blue-600 w-full mt-3">Submit</button>
          ) : (
            <div className="flex flex-col gap-2 mt-3">
              <button className="btn bg-green-600 w-full" onClick={onStartNewCycle}>Start New Cycle</button>
              <button className="btn bg-gray-700 w-full" onClick={onContinueCycle}>Continue This Cycle</button>
            </div>
          )}
        </div>
      );
    }

    /* ======= History export helpers ======= */
    function collectAllHistory(){
      const out = {};
      for(let i=0;i<localStorage.length;i++){
        const k = localStorage.key(i);
        if(k && k.startsWith('history:')){
          out[k] = lsGet(k,[]);
        }
      }
      return out;
    }
    function exportJSON(){
      const data = collectAllHistory();
      const blob = new Blob([JSON.stringify(data,null,2)], {type:"application/json"});
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url; a.download = `everstrong-history-${new Date().toISOString().slice(0,10)}.json`;
      document.body.appendChild(a); a.click(); a.remove();
      URL.revokeObjectURL(url);
    }
    function toCSV(rows){
      const esc = v => `"${String(v??"").replace(/"/g,'""')}"`;
      const header = ["saved_at","modality","choice","cycle","phase","session","date","timer_seconds","su","lines"];
      const out = [header.join(",")];
      rows.forEach(r=>{
        const m=r.meta||{};
        out.push([
          r.saved_at||"",
          m.modality||"",
          m.choice||"",
          m.cycle??"",
          m.phase??"",
          m.session??"",
          m.date?new Date(m.date).toISOString():"",
          r.timer_seconds??"",
          m.su??"",
          (r.main||[]).join(" | ")
        ].map(esc).join(","));
      });
      return out.join("\n");
    }
    function exportCSV(){
      const all = collectAllHistory();
      const rows = Object.values(all).flat();
      const csv = toCSV(rows);
      const blob = new Blob([csv], {type:"text/csv"});
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url; a.download = `everstrong-history-${new Date().toISOString().slice(0,10)}.csv`;
      document.body.appendChild(a); a.click(); a.remove();
      URL.revokeObjectURL(url);
    }
    function clearAllHistory(){
      if(!confirm("This will permanently delete ALL history (all modalities, tests, specials). Continue?")) return;
      const keysToDelete = [];
      for(let i=0;i<localStorage.length;i++){
        const k = localStorage.key(i);
        if(k && k.startsWith('history:')){
          keysToDelete.push(k);
        }
      }
      keysToDelete.forEach(k=>{ try{ localStorage.removeItem(k); }catch(e){} });
      alert("All history cleared.");
    }

    /* ===== ACTIVE RECOVERY (3 opties + DurabilitySequence lijst) ===== */
    function chooseDurabilitySequence(){
      const lines = [
        "DurabilitySequence — quality over quantity; pain-free range.",
        "",
        "Hack Squat",
        "* 2×5–8",
        "Jefferson Curl",
        "* 2×5 (slow, full control)",
        "Hockey Deadlift",
        "* 2×5–8",
        "Bretzell (Stretch)",
        "* 2×20–30 sec per side",
        "Bretzel Armbar",
        "* 2×3–5 per side",
        "Arm Bar",
        "* 2×3–5 per side",
        "Bent Arm Bar + Press",
        "* 2×3–5 per side",
        "Get Up Arm Rotations",
        "* 3–5 per side",
        "Get Up Neck Rotations",
        "* 3–5 per side",
        "SOS Get Up",
        "* 2–3 per side",
        "",
        "Hanging Series",
        "* Front Lever (tuck) — 3–5 sec holds × 3",
        "* Skin the Cat — 3–5 smooth reps",
        "* Active Hang — 2×10–20 sec",
        "* Passive Hang — 2×20–30 sec",
        "* Arm & Leg Movement — 2×5–8",
        "* Jump & Brace — 3–5 jumps",
        "",
        "Elevated Gymnastic Bridge Series",
        "* Bridge Hold — 2×10–20 sec",
        "Hip Flexor Stretch Overhead Kettlebell",
        "* 2×20–30 sec per side",
        "",
        "Neck Series",
        "* Flexion / Extension — 5–8 each",
        "* Lateral Tilt — 5–8 each",
        "* Rotation — 5–8 each"
      ];
      const recSession = { main: lines, meta: { modality:'recovery', date: new Date().toISOString(), choice:'DurabilitySequence' } };
      return recSession;
    }

    /* ======= FULL MOBILITYSEQUENCE GENERATOR (General) ======= */
    const MOBILITY_DB_GENERAL = [
      "Figure 4 Position → Figure 4 Lunge → Half Heel Sit",
      "Z-position Switches → Z-position Side Roll",
      "Prone to Get-Up Bridge (Hip Opener Sequence)",

      "Egyptian Arms (Seated → Pike → Prone)",
      "S-Movement (Seated → Pike → Prone)",
      "Figure 8 in 6pt → Transition to 4pt",
      "Crawl to Crab → Pike to Tabletop",

      "Ankle Series (Up/Down, In/Out, Rotations)",
      "Figure 8 with Toes and Ankle",
      "Snail Crawl → Frog → Crab Flow",

      "Supine Neck Rolls + Segmental Spine Rolls",
      "Hand-on-Knee Rolls + Forward/Backward Rolling",

      "Finger Waves → Hand Circles → Tea Pot (Wrist Flow)",

      "4pt Crawl → Push-Up → Pike → Squat → Crab",
      "Shoulder Mobility Drill → Prone S Transition → 4pt Crawl",
      "Half Heel Sit → Roll to Supine → Segmental Roll to Prone",
      "6pt X-Lift → Prone Rotation → Crab Reach with Control",

      "Static Beast Hold → Dynamic Beast Crawl",
      "Crab Reach (slow, controlled)",
      "Underswitch from Beast to Crab",
      "Scorpion Prep from Prone (hip rotation, no kick)",
      "Side Travelling Ape (low squat lateral walk)",
      "Loaded Beast → Wave Unload (slow)"
    ];
    function chooseGFMFlow(){
      const src = MOBILITY_DB_GENERAL.slice();
      for (let i = src.length - 1; i > 0; i--) { const j = Math.floor(Math.random() * (i + 1)); [src[i], src[j]] = [src[j], src[i]]; }
      const pickCount = 7;
      const steps = src.slice(0, pickCount);
      const lines = [
  "MobilitySequence (~15–20 min):",
  "",
  ...steps.map((s, i) => `${i + 1}) ${s} — 1–2 min`)
];

      return { main: lines, meta: { modality: "recovery", date: new Date().toISOString(), choice: "MobilitySequence" } };
    }
    function chooseZone2Only(){
      const lines = ["Zone #2", "* Do 30 minutes of continuous Zone 2 cardio (walking, cycling, rowing, etc.)."];
      return { main: lines, meta: { modality:'recovery', date:new Date().toISOString(), choice:'Zone #2' } };
    }

    /* ===== Optional Finishers ===== */
    const FINISHERS_DB = {
      biceps: ["Zottman Curl", "Hammer Curl", "Concentration Curl"],
      triceps: ["KB Overhead Extension", "Diamond Push-up", "Bench Dips"],
      abs: ["Ab-wheel Rollout", "Landmine/Russian Twist", "Side Bend"],
      clubmace: ["Mace 360", "Clubbell Mills", "Clubbell Swipe", "Half Kneeling Shield Cast"]
    };
    function buildFinishersLines(){
      const picks = Object.entries(FINISHERS_DB).map(([cat,arr])=>{
        const pick = arr[Math.floor(Math.random()*arr.length)];
        const label = cat==='clubmace' ? 'Club/Mace' : cat[0].toUpperCase()+cat.slice(1);
        return `* ${label}: ${pick} — 2×12`;
      });
      return ["", "Finishers (optional):", "", ...picks];
    }

    /* ======= Score Selectors (0–5 buttons with text) ======= */
    const SCORE_SCALES = {
      sleep: [
        "0 – Barely slept, not recovered",
        "1 – Very poor sleep, broken",
        "2 – Restless, too short, not refreshed",
        "3 – Okay, enough to get by",
        "4 – Good, rested",
        "5 – Excellent, fully recovered"
      ],
      energy: [
        "0 – No energy at all, exhausted",
        "1 – Very low, hard to move",
        "2 – Low, sluggish",
        "3 – Okay, manageable",
        "4 – Good, energetic",
        "5 – Excellent, buzzing with energy"
      ],
      body: [
        "0 – Severe pain/injury, not trainable",
        "1 – Major stiffness/pain, very limited",
        "2 – Noticeable stiffness/pain, but can move",
        "3 – Slight stiffness/fatigue, usable",
        "4 – Good, minimal limitations",
        "5 – Excellent, loose and strong"
      ]
    };
    function ScoreSelector({ label, keyName, value, onChange }){
      const scale = SCORE_SCALES[keyName];
      return (
        <div className="mb-3">
          <div className="font-medium mb-1">{label}</div>
          <div className="flex flex-wrap gap-2">
            {scale.map((desc, idx)=>(
              <button
                key={idx}
                className={`px-3 py-1.5 rounded-lg text-sm border ${
                  value===idx ? "bg-blue-600 text-white" : "bg-gray-200 dark:bg-gray-800"
                }`}
                onClick={()=>onChange(idx)}
              >
                {idx}
              </button>
            ))}
          </div>
          {value!=null && <div className="text-xs text-gray-500 dark:text-gray-400 mt-1">{scale[value]}</div>}
        </div>
      );
    }
    /* =================== App =================== */
    function App(){
      const [modality,setModality]=useState(lsGet("modality","kettlebell"));
      useEffect(()=>lsSet("modality",modality),[modality]);
useEffect(() => {
  function handleStartInferno() {
    // stap 1: wissel naar Train tab
    setActiveTab('train');
    lsSet('ui:tab','train');

    // stap 2: na 1 “tick” Inferno pinnen
    setTimeout(() => {
      try {
        openHiitChooser(); // normale weg
      } catch (e) {
        if (typeof pinInferno === 'function') pinInferno(400); // fallback
      }
    }, 0);
  }

  // luister naar event vanuit Settings
  window.addEventListener('everstrong:start-inferno', handleStartInferno);

  // netjes opruimen
  return () => {
    window.removeEventListener('everstrong:start-inferno', handleStartInferno);
  };
}, []);


      const [session,setSession]=useState(null);
      const [elapsed,setElapsed]=useState(0);
      const [running,setRunning]=useState(false);

      // Recovery scores (0–5)
      const [sleepScore,setSleepScore]=useState(lsGet("rec:sleep",null));
      const [energyScore,setEnergyScore]=useState(lsGet("rec:energy",null));
      const [bodyScore,setBodyScore]=useState(lsGet("rec:body",null));
      useEffect(()=>lsSet("rec:sleep",sleepScore),[sleepScore]);
      useEffect(()=>lsSet("rec:energy",energyScore),[energyScore]);
      useEffect(()=>lsSet("rec:body",bodyScore),[bodyScore]);

      const totalRecovery = (sleepScore??0)+(energyScore??0)+(bodyScore??0);
      const gateDecision = totalRecovery>=11 ? "train" : totalRecovery>=7 ? "recovery" : "fullrest";

      const [route, setRoute] = useState("gate");
      const [recoveryMode, setRecoveryMode] = useState(lsGet("recovery:mode","gate"));
      useEffect(()=>lsSet("recovery:mode", recoveryMode),[recoveryMode]);

      // per-day recovery counter (max 2)
      const REC_MAX = 2;
      const [recoveryCount,setRecoveryCount]=useState(lsGet(`recovery:count:${todayKey()}`,0));
      useEffect(()=>{
        const k=`recovery:count:${todayKey()}`;
        const cur=lsGet(k,null);
        if(cur===null){ lsSet(k,0); setRecoveryCount(0); }
      },[]);
      function incRecoveryCount(){
        const k=`recovery:count:${todayKey()}`;
        const c=(lsGet(k,0)||0)+1; lsSet(k,c); setRecoveryCount(c);
      }

      // Optional finishers toggle
      const [finishersEnabled, setFinishersEnabled] = useState(lsGet("finishers:enabled", false));
      useEffect(()=>lsSet("finishers:enabled", finishersEnabled),[finishersEnabled]);

      // Enabled modalities
      const DEFAULT_ENABLED = { kettlebell:true, barbell:true, bodyweight:true };
      const [enabled, setEnabled] = useState(lsGet("modalities:enabled", DEFAULT_ENABLED));
      useEffect(()=>{ lsSet("modalities:enabled", enabled); }, [enabled]);
      const enabledList = useMemo(()=>Object.keys(enabled).filter(k=>enabled[k]), [enabled]);
      useEffect(()=>{
        if (!enabled[modality]) {
          const fallback = enabledList[0] || "kettlebell";
          if (fallback !== modality) {
            setModality(fallback);
            const cur = ensurePinnedFor(fallback);
            setSession(cur);
          }
        }
      }, [enabled, modality]);

      // Suggestie
      const [lastCompletedModality, setLastCompletedModality] = useState(lsGet("lastCompletedModality", null));
      const [suggestion, setSuggestion] = useState(null);

      // Inferno suggestion (friendly quick button)
      const [infernoAuto, setInfernoAuto] = useState(lsGet("inferno:auto","off")); // "off" | "14" | "21"
      const [infernoNextDue, setInfernoNextDue] = useState(lsGet("inferno:next_due", null));
      const infernoDueNow = useMemo(()=>{
        if(infernoAuto==="off" || !infernoNextDue) return false;
        return isSameOrBefore(infernoNextDue, todayISO());
      }, [infernoAuto, infernoNextDue]);

      function engineFor(m){ return m==='kettlebell'?KETTLEBELLENGINE : m==='barbell'?BARBELLENGINE : BODYWEIGHTENGINE; }
      function currentKey(m){ return `current:${m}`; }
      function historyKey(m){ return `history:${m}`; }

      function maybeAppendFinishers(sessionObj){
        const m = sessionObj?.meta?.modality;
        if(!finishersEnabled) return sessionObj;
        if(['kettlebell','barbell','bodyweight'].includes(m || '')){
          const lines = buildFinishersLines();
          const out = { ...sessionObj, main: [...(sessionObj.main||[]), ...lines] };
          return out;
        }
        return sessionObj;
      }

      function ensurePinnedFor(mod){
        let cur = lsGet(currentKey(mod), null);
        if(!cur){
          const eng = engineFor(mod);
          let s = eng.generate_single_session();
          s.meta.modality = mod;
          s = maybeAppendFinishers(s);
          lsSet(currentKey(mod), s);
          cur = s;
        }
        return cur;
      }
      function recomputeSuggestion(baseMod = null){
        const last = baseMod || lastCompletedModality || getLatestMainModalityFromHistory() || lsGet("last_modality", null);
        const pool = enabledList;
        const candidates = last ? pool.filter(m=>m!==last) : pool;
        if(candidates.length===0){ setSuggestion(null); return; }
        const pick = candidates[Math.floor(Math.random()*candidates.length)];
        const pinned = ensurePinnedFor(pick);
        setSuggestion({ modality: pick, session: pinned });
      }

      useEffect(()=>{
        const cur=lsGet(currentKey(modality),null);
        setSession(cur);
        setElapsed(0); setRunning(false);
      },[modality]);

      useEffect(()=>{
        if(recoveryMode==="gate"){
          const stamp = lsGet("recovery:stamp", null);
          const today = todayStr();
          setRoute(stamp===today ? lsGet("recovery:lastRoute","train") : "gate");
        } else {
          setRoute("train");
        }
      },[recoveryMode]);

      useEffect(()=>{ recomputeSuggestion(); },[lastCompletedModality]);

      // Initialize inferno next_due on first enable
      useEffect(()=>{
        if(infernoAuto!=="off"){
          let next = lsGet("inferno:next_due", null);
          if(!next){
            next = addDays(todayISO(), parseInt(infernoAuto,10));
            lsSet("inferno:next_due", next);
          }
          setInfernoNextDue(lsGet("inferno:next_due", next));
        }
      }, []);

      function toggleDark(){ document.documentElement.classList.toggle('dark'); }

      function restartSelected(){
        if(session && session.meta && ['hiit','recovery','breathing','warmup','kettlebell_test','barbell_test','bodyweight_test'].includes(session.meta.modality)){
          try{localStorage.removeItem(currentKey(session.meta.modality));}catch(e){}
        }
        const eng=engineFor(modality);
        eng.hardResetToStart();
        try{localStorage.removeItem(currentKey(modality));}catch(e){}
        setSession(null); setElapsed(0); setRunning(false);
        alert('Reset to 1.1.1 for '+modality);
        recomputeSuggestion();
      }
      function generateCycle(){
        const eng=engineFor(modality);
        eng.hardResetToStart();
        let s=eng.generate_single_session();
        s.meta.modality=modality;
        s = maybeAppendFinishers(s);
        lsSet(currentKey(modality),s);
        setSession(s);
        setElapsed(0); setRunning(false);
        recomputeSuggestion();
      }
      function saveToHistory(s, mod){
        const m = mod || modality;
        const arr=lsGet(historyKey(m),[]);
        arr.push({ saved_at:new Date().toISOString(), timer_seconds:elapsed||0, main:s.main, meta:s.meta });
        lsSet(historyKey(m),arr);
      }
      function updatePerformance(perf){
        if(!session) return;
        const next = { ...session, meta: { ...session.meta, performance: perf } };
        lsSet(`current:${session.meta?.modality || modality}`, next);
        setSession(next);
      }

function pinInferno(target=400){
  if(!window.HELLFIRE_GENERATE){ alert("Inferno engine unavailable"); return; }
  const out = window.HELLFIRE_GENERATE(target);
  const hiitSession = { main: out.lines, meta: { modality:'hiit', su: out.su||target, date: new Date().toISOString() } };
  lsSet(currentKey('hiit'), hiitSession);
  // setModality('hiit');  // weg
  setSession(hiitSession);
  setElapsed(0); setRunning(false);
}

      function openHiitChooser(){ pinInferno(400); }

      function openWarmup(){
        const lines = [
          "Warm-up — do between 10 reps and your age per movement",
          "",
          "* Three-Way Neck",
          "* Fingers and Wrists",
          "* Elbow Circles",
          "* Kettlebell Halo",
          "* Egyptian",
          "* Hip Circles",
          "* Knee Circles",
          "* Toes, Feet, and Ankles",
          "* Crocodile Breathing",
          "* Prying Cobra / Down Dog",
          "* Cat-Camel (McGill)",
          "* Frog",
          "* Tug-of-War Squats"
        ];
        const wSession = { main: lines, meta: { modality:'warmup', date:new Date().toISOString() } };
        lsSet(currentKey('warmup'), wSession);
        setSession(wSession);
        setElapsed(0); setRunning(false);
      }

      // Recovery chooser: 3 opties
      function openRecoverySession(kind){
        let rec=null;
        if(kind==='DurabilitySequence'){ rec = chooseDurabilitySequence(); }
        else if(kind==='gfm'){ rec = chooseGFMFlow(); }
        else { rec = chooseZone2Only(); }
        lsSet(`current:recovery`, rec);
        setSession(rec);
        setElapsed(0); setRunning(false);
      }
function openBreathing(minutes=10, level="Beginner"){
  const b = buildBreathingSession(minutes, level);
  lsSet("current:breathing", b);
  setSession(b);
  setElapsed(0); 
  setRunning(false);
}
      const [testChecks, setTestChecks] = useState({});
      const [testPassed, setTestPassed] = useState(false);

      function submitTestResult(){
        const mod = session?.meta?.modality; // 'kettlebell_test' | 'barbell_test' | 'bodyweight_test'
        const isKB = (mod === 'kettlebell_test');
        const isBB = (mod === 'barbell_test');
        const isBW = (mod === 'bodyweight_test');

        const total = isKB ? KB_TEST_ITEMS.length : isBB ? BB_REVIEW_ITEMS.length : BW_REVIEW_ITEMS.length;
        const passed = Object.values(testChecks).filter(Boolean).length;

        const histKey = `history:${isKB ? 'kettlebell_test' : isBB ? 'barbell_test' : 'bodyweight_test'}`;
        const arr = lsGet(histKey, []);
        arr.push({ saved_at: new Date().toISOString(), meta: session.meta, main: session.main, passed, total });
        lsSet(histKey, arr);

        if(passed === total){
          setTestPassed(true);
        } else {
          const eng = isKB ? KETTLEBELLENGINE : isBB ? BARBELLENGINE : BODYWEIGHTENGINE;
          if(eng.current_phase < 3){
            eng.current_phase += 1;
          } else {
            eng.current_phase = 3; // hold
          }
          eng.session_count = 0;
          eng.exercise_usage_count = {};
          eng.last_session_exercises = [];
          eng.last_session_volumes = {};
          eng.all_sessions = [];
          eng.persist();

          try{ localStorage.removeItem(`current:${isKB?'kettlebell': isBB?'barbell':'bodyweight'}_test`); }catch(e){}
          let next = eng.generate_single_session();
          next.meta.modality = isKB ? 'kettlebell' : isBB ? 'barbell' : 'bodyweight';
          next = maybeAppendFinishers(next);
          lsSet(`current:${next.meta.modality}`, next);
          setSession(next);
          setTestChecks({});
          setTestPassed(false);
          recomputeSuggestion(next.meta.modality);
        }
      }
      function startNewCycle(){
        const mod = session?.meta?.modality;
        const eng = mod==='kettlebell_test' ? KETTLEBELLENGINE : mod==='barbell_test' ? BARBELLENGINE : BODYWEIGHTENGINE; // bodyweight_test → BODYWEIGHTENGINE
        eng.startNewCycle?.();

        try{ localStorage.removeItem(`current:${mod}`); }catch(e){}
        let next = eng.generate_single_session();
        next.meta.modality = (mod==='kettlebell_test' ? 'kettlebell' : mod==='barbell_test' ? 'barbell' : 'bodyweight');
        next = maybeAppendFinishers(next);
        lsSet(`current:${next.meta.modality}`, next);
        setSession(next);
        setTestChecks({});
        setTestPassed(false);
        recomputeSuggestion(next.meta.modality);
      }
      function continueThisCycle(){
        const mod = session?.meta?.modality;
        const eng = mod==='kettlebell_test' ? KETTLEBELLENGINE : mod==='barbell_test' ? BARBELLENGINE : BODYWEIGHTENGINE; // bodyweight_test → BODYWEIGHTENGINE

        if(eng.current_phase < 3){
          eng.current_phase += 1;
        } else {
          eng.current_phase = 3;
        }
        eng.session_count = 0;
        eng.exercise_usage_count = {};
        eng.last_session_exercises = [];
        eng.last_session_volumes = {};
        eng.all_sessions = [];
        eng.persist();

        try{ localStorage.removeItem(`current:${mod}`); }catch(e){}
        let next = eng.generate_single_session();
        next.meta.modality = (mod==='kettlebell_test' ? 'kettlebell' : mod==='barbell_test' ? 'barbell' : 'bodyweight');
        next = maybeAppendFinishers(next);
        lsSet(`current:${next.meta.modality}`, next);
        setSession(next);
        setTestChecks({});
        setTestPassed(false);
        recomputeSuggestion(next.meta.modality);
      }

      function completeSession(){
        if(!session) return;
        setRunning(false);
        const metaMod = session.meta?.modality;

        // Warm-up (not saved)
        if(metaMod==='warmup'){
          try{localStorage.removeItem(currentKey('warmup'));}catch(e){};
          setSession(null);
          alert("Warm-up closed.");
          return;
        }

        // HIIT: log + schedule next suggestion (friendly)
        if(metaMod==='hiit'){
          try{localStorage.removeItem(currentKey('hiit'));}catch(e){};
          const histKeySpecial = historyKey('hiit');
          const arr = lsGet(histKeySpecial,[]);
          arr.push({ saved_at:new Date().toISOString(), timer_seconds:elapsed||0, main:session.main, meta:session.meta });
          lsSet(histKeySpecial, arr);

          const auto = lsGet("inferno:auto","off");
          if(auto !== "off"){
            const interval = parseInt(auto,10); // 14 or 21
            const nextDue = addDays(todayISO(), interval);
            lsSet("inferno:next_due", nextDue);
            setInfernoNextDue(nextDue);
          }

          setSession(null);
          alert('Inferno saved.');
          recomputeSuggestion();
          return;
        }

        // Recovery: log + count
        if(metaMod==='recovery'){
          try{localStorage.removeItem(currentKey('recovery'));}catch(e){};
          const histKeySpecial = historyKey('recovery');
          const arr = lsGet(histKeySpecial,[]);
          arr.push({ saved_at:new Date().toISOString(), timer_seconds:elapsed||0, main:session.main, meta:session.meta });
          lsSet(histKeySpecial, arr);
          incRecoveryCount();
          setSession(null);
          alert('Active Recovery saved to history.');
          return;
        }
// Breathing: log
if (metaMod === 'breathing') {
  try{ localStorage.removeItem(currentKey('breathing')); }catch(e){}
  const histKeySpecial = historyKey('breathing');
  const arr = lsGet(histKeySpecial, []);
  arr.push({ saved_at:new Date().toISOString(), timer_seconds:elapsed||0, main:session.main, meta:session.meta });
  lsSet(histKeySpecial, arr);
  setSession(null);
  alert('Breathing saved to history.');
  return;
}


        // Strength: log
        saveToHistory(session, metaMod || modality);

        // Phase-end behaviour
        if (session?.meta?.phase_end && modality==='kettlebell'){
          const t = buildKbTestSession();
          lsSet('current:kettlebell_test', t);
          setSession(t);
          setTestChecks({});
          setTestPassed(false);
          setLastCompletedModality('kettlebell'); lsSet("lastCompletedModality",'kettlebell');
          recomputeSuggestion('kettlebell');
          return;
        }
        if (session?.meta?.phase_end && modality==='barbell'){
          const t = buildBbReviewSession();
          lsSet('current:barbell_test', t);
          setSession(t);
          setTestChecks({});
          setTestPassed(false);
          setLastCompletedModality('barbell'); lsSet("lastCompletedModality",'barbell');
          recomputeSuggestion('barbell');
          return;
        }
        if (session?.meta?.phase_end && modality==='bodyweight'){
          const t = buildBwReviewSession();
          lsSet('current:bodyweight_test', t);
          setSession(t);
          setTestChecks({});
          setTestPassed(false);
          setLastCompletedModality('bodyweight'); lsSet("lastCompletedModality",'bodyweight');
          recomputeSuggestion('bodyweight');
          return;
        }

        // Default: next session same modality
        const eng=engineFor(modality);
        let s=eng.generate_single_session();
        s.meta.modality=modality;
        s = maybeAppendFinishers(s);
        lsSet(currentKey(modality),s);
        setSession(s);
        setElapsed(0);

        // For suggestion: remember last completed modality
        setLastCompletedModality(modality);
        lsSet("lastCompletedModality", modality);
        recomputeSuggestion(modality);
      }

      /* ======= UI: Tabs + Calm layout ======= */
      const [activeTab, setActiveTab] = useState(lsGet("ui:tab","train"));
      useEffect(()=>lsSet("ui:tab",activeTab),[activeTab]);
      const [calm, setCalm] = useState(lsGet("ui:calm", true));

      // Pages
      const PageTrain = (
        <>
          {/* Suggested Next */}
          {suggestion && suggestion.session && enabledList.length >= (suggestion.modality==='hiit' ? 0 : 2) && (
            <CalmCard title="Suggested Next">
              <p className="mb-2 text-sm text-gray-500 dark:text-gray-400">
                Based on your last session, try this next:
              </p>
              <button
                className="btn bg-blue-600 w-full"
                onClick={()=>{
                  setModality(suggestion.modality);
                  const pinned = ensurePinnedFor(suggestion.modality);
                  setSession(pinned);
                }}
              >
                {suggestion.modality.charAt(0).toUpperCase()+suggestion.modality.slice(1)} — {suggestion.session.meta.cycle}.{suggestion.session.meta.phase}.{suggestion.session.meta.session}
              </button>
            </CalmCard>
          )}

          {/* Quick Switch + Inferno Ready (friendly button) */}
          <CalmCard title="Quick Actions" subtitle="Pick your modality or open a warm-up.">
            <div className="flex flex-wrap gap-2">
              <ModalityToggles
                modality={session?.meta?.modality==='hiit'?'bodyweight':modality}
                setModality={m=>{ if(m==='hiit')return; setModality(m); const cur=ensurePinnedFor(m); setSession(cur); }}
                lastModalityVisual={getLatestMainModalityFromHistory() || lsGet("last_modality", null) || null}
                enabled={enabled}
              />
              <button onClick={openWarmup} className="btn bg-emerald-700">Warm-up</button>

              {infernoAuto!=="off" && infernoDueNow && (
                <button
                  className="btn bg-indigo-600"
                  title={`It's time again (due since ${new Date(infernoNextDue).toLocaleDateString()})`}
                  onClick={()=>pinInferno(400)}
                >
                  Inferno (Ready)
                </button>
              )}
            </div>
            {infernoAuto!=="off" && infernoDueNow && (
              <p className="text-xs text-gray-500 dark:text-gray-400 mt-2">
                It’s been {infernoAuto} days since your last Inferno — you’re ready for another dose.
              </p>
            )}
          </CalmCard>

          {!session && (
            <CalmCard title="Get started">
              <div className="flex flex-col gap-2">
                <button onClick={generateCycle} className="btn bg-blue-600 w-full">Generate Cycle (start at 1.1.1)</button>
                <div className="flex gap-2">
  <button onClick={openWarmup} className="btn bg-emerald-700 w-full">Warm-up</button>
<button
  onClick={() => {
    // eerst naar Train-tab
    setActiveTab('train');
    lsSet('ui:tab','train');

    // daarna Inferno pinnen (400 SU)
    setTimeout(() => {
      try {
        openHiitChooser(); // normale weg
      } catch (e) {
        if (typeof pinInferno === 'function') pinInferno(400); // fallback
      }
    }, 0);
  }}
  className="btn bg-indigo-600 w-full"
  title="Start Inferno (400 SU) en ga naar Train"
>
  Start Inferno (400 SU)
</button>

</div>
              </div>
            </CalmCard>
          )}

          {session && (
            <CalmCard title="Session" subtitle="Pinned until Complete">
              {(session.meta?.modality==='kettlebell_test' || session.meta?.modality==='barbell_test' || session.meta?.modality==='bodyweight_test')
                ? (
                  <TestView
                    modality={
                      session.meta.modality==='kettlebell_test' ? 'kettlebell'
                      : session.meta.modality==='barbell_test' ? 'barbell'
                      : 'bodyweight'
                    }
                    testChecks={testChecks}
                    setTestChecks={setTestChecks}
                    testPassed={testPassed}
                    onSubmit={submitTestResult}
                    onStartNewCycle={startNewCycle}
                    onContinueCycle={continueThisCycle}
                  />
                ) : (
                  <SessionView session={session}/>
                )
              }
              <div className="flex gap-2 mt-2">
                {session?.meta?.modality==='warmup' ? (
                  <button
                    onClick={()=>{ try{localStorage.removeItem(`current:warmup`);}catch(e){}; setSession(null); }}
                    className="btn-sm bg-gray-600 w-full"
                    title="Close warm-up (not saved)"
                  >
                    Close Warm-up
                  </button>
                ) : (
                  <>
                    <button onClick={completeSession} className="btn-sm bg-green-600 w-1/2" disabled={!session}>Complete</button>
                    {session?.meta?.modality!=='warmup' && (
                      <button onClick={openWarmup} className="btn-sm bg-emerald-700 w-1/2">Warm-up</button>
                    )}
                  </>
                )}
              </div>
            </CalmCard>
          )}

          {session && !['warmup','breathing','recovery','kettlebell_test','barbell_test','bodyweight_test','hiit'].includes(session?.meta?.modality) && (
            <CalmCard title="Performance">
              <PerformanceForm session={session} onChange={updatePerformance}/>
            </CalmCard>
          )}

          <CalmCard title="Timer">
            <Timer elapsed={elapsed} setElapsed={setElapsed} running={running} setRunning={setRunning} />
          </CalmCard>
        </>
      );

      const PageRecovery = (
        <>
          {recoveryMode==="inline" && (
            <Accordion title="Recovery Check" defaultOpen>
              <ScoreSelector label="Sleep Quality" keyName="sleep" value={sleepScore} onChange={setSleepScore}/>
              <ScoreSelector label="Energy" keyName="energy" value={energyScore} onChange={setEnergyScore}/>
              <ScoreSelector label="Body Readiness" keyName="body" value={bodyScore} onChange={setBodyScore}/>
              <p className="text-sm mt-1">Total: {totalRecovery||0} → <strong>{gateDecision.toUpperCase()}</strong></p>
            </Accordion>
          )}

          {/* Auto-selected Recovery from gate */}
{['recovery','breathing'].includes(session?.meta?.modality) && (
  <CalmCard title="Pinned Recovery (auto-selected)" subtitle="From your daily recovery gate">
    <SessionView session={session}/>
    <div className="flex gap-2 mt-2">
      <button onClick={completeSession} className="btn-sm bg-green-600 w-full">Complete</button>
    </div>
  </CalmCard>
)}

{/* Manual extra options */}
<Accordion title="Extra Recovery Options" defaultOpen>
  <p className="text-sm text-gray-500 dark:text-gray-400 mb-2">
    Use these if you want to add another recovery block, or override today’s auto-selected session.
  </p>
  <div className="flex flex-col md:flex-row gap-2">
    <button className="btn bg-gray-700 w-full" onClick={()=>openRecoverySession('DurabilitySequence')}>DurabilitySequence</button>
    <button className="btn bg-gray-700 w-full" onClick={()=>openRecoverySession('gfm')}>MobilitySequence</button>
    <button className="btn bg-gray-700 w-full" onClick={()=>openRecoverySession('zone2')}>Zone #2</button>
    <button className="btn bg-gray-700 w-full" onClick={()=>openBreathing(10,'Beginner')}>Breathing (10 min)</button>
  </div>
</Accordion>


          <Accordion title="Recovery History">
            <History modality="recovery" />
            <div className="mt-3">
              <button
                className="btn bg-gray-700 w-full disabled:opacity-40"
                onClick={()=>{
                  const dlg = document.getElementById('addRecoveryDlg');
                  dlg?.showModal();
                }}
                disabled={recoveryCount >= REC_MAX}
                title={recoveryCount >= REC_MAX ? "Daily recovery limit reached" : "Add another recovery block"}
              >
                Log another recovery
              </button>
              <p className="text-[11px] text-gray-500 mt-1">
                {recoveryCount >= REC_MAX ? "Daily limit reached (2)." : "You can log up to 2 recovery blocks per day."}
              </p>
            </div>
          </Accordion>

          <dialog id="addRecoveryDlg" className="rounded-xl p-0 w-80 bg-white dark:bg-gray-900 border border-black/10 dark:border-white/10">
            <div className="p-3 border-b border-black/10 dark:border-white/10 flex items-center justify-between">
              <span className="font-semibold">Add Recovery</span>
              <button onClick={()=>document.getElementById("addRecoveryDlg").close()} className="p-1 rounded hover:bg-black/5 dark:hover:bg-white/5">✕</button>
            </div>
            <div className="p-3 space-y-2">
              <button className="btn bg-gray-700 w-full" onClick={()=>{ openRecoverySession('DurabilitySequence'); document.getElementById("addRecoveryDlg").close(); }}>DurabilitySequence</button>
              <button className="btn bg-gray-700 w-full" onClick={()=>{ openRecoverySession('gfm'); document.getElementById("addRecoveryDlg").close(); }}>MobilitySequence</button>
              <button className="btn bg-gray-700 w-full" onClick={()=>{ openRecoverySession('zone2'); document.getElementById("addRecoveryDlg").close(); }}>Zone #2</button>
            </div>
          </dialog>
        </>
      );

      const PageHistory = (
        <CalmCard title="History">
          <History modality={(session && session.meta && session.meta.modality) ? session.meta.modality : modality} />
        </CalmCard>
      );

      const PageExport = (
        <CalmCard title="Export & Maintenance">
          <div className="flex flex-col md:flex-row gap-2">
            <button className="btn bg-gray-700 w-full" onClick={exportJSON}>Export JSON</button>
            <button className="btn bg-gray-700 w-full" onClick={exportCSV}>Export CSV</button>
            <button className="btn bg-red-700 w-full" onClick={clearAllHistory}>Reset History (All)</button>
          </div>
        </CalmCard>
      );

      const PageSettings = (
        <CalmCard title="Settings">
          <div className="space-y-3">
            <div className="flex items-center justify-between">
              <span className="text-sm">Calm mode (softer UI)</span>
              <input type="checkbox" checked={lsGet('ui:calm', true)} onChange={(e)=>{ lsSet('ui:calm', e.target.checked); location.reload(); }} />
            </div>

            <div className="flex items-center justify-between">
              <span className="text-sm">Recovery mode</span>
              <button
                className="px-3 py-1 rounded-lg text-sm bg-gray-700"
                onClick={()=>setRecoveryMode(m=> m==="gate" ? "inline" : "gate")}
              >
                {recoveryMode === "gate" ? "Gate" : "Inline"}
              </button>
            </div>

            <div className="border-t border-black/10 dark:border-white/10 pt-3">
              <p className="text-sm font-medium mb-2">Enabled modalities</p>
              <div className="space-y-2">
                {["kettlebell","barbell","bodyweight"].map(id=>(
                  <label key={id} className="flex items-center justify-between">
                    <span className="capitalize">{id}</span>
                    <input
                      type="checkbox"
                      checked={!!enabled[id]}
                      onChange={(e)=>{
                        const next = { ...enabled, [id]: e.target.checked };
                        const willBeEnabled = Object.keys(next).filter(k=>next[k]);
                        if (willBeEnabled.length===0) {
                          alert("At least one modality must remain enabled.");
                          return;
                        }
                        setEnabled(next);
                      }}
                    />
                  </label>
                ))}
              </div>
              <p className="mt-2 text-xs text-gray-500 dark:text-gray-400">
                Only enabled modalities appear in Suggested Next, Quick Switch, and rotation.
              </p>
            </div>

            <div className="border-t border-black/10 dark:border-white/10 pt-3">
              <p className="text-sm font-medium mb-2">Optional finishers</p>
              <label className="flex items-center justify-between">
                <span>Add Biceps / Triceps / Abs / Club-Mace after strength sessions</span>
                <input
                  type="checkbox"
                  checked={finishersEnabled}
                  onChange={(e)=>setFinishersEnabled(e.target.checked)}
                />
              </label>
            </div>

            <div className="border-t border-black/10 dark:border-white/10 pt-3">
              <p className="text-sm font-medium mb-2">Inferno Suggestion</p>
              <select
                value={infernoAuto}
                onChange={e=>{
                  const val = e.target.value;
                  lsSet("inferno:auto", val);
                  setInfernoAuto(val);
                  if(val !== "off"){
                    const next = addDays(todayISO(), parseInt(val,10));
                    lsSet("inferno:next_due", next);
                    setInfernoNextDue(next);
                  } else {
                    lsSet("inferno:next_due", null);
                    setInfernoNextDue(null);
                  }
                }}
                className="border rounded p-2 w-full bg-white dark:bg-gray-700"
              >
                <option value="off">Off (no suggestion)</option>
                <option value="14">Suggest every 14 days</option>
                <option value="21">Suggest every 21 days</option>
              </select>
              <p className="mt-2 text-xs text-gray-500 dark:text-gray-400">
                A friendly “Inferno (Ready)” button will appear in Quick Actions when it’s time again. No pressure—recovery gates still apply.
              </p>
            </div>

            <div className="border-t border-black/10 dark:border-white/10 pt-3">
              <p className="text-xs text-gray-500 dark:text-gray-400">Default Modality</p>
              <div className="mt-1">
                <ModalityToggles
                  modality={session?.meta?.modality==='hiit'?'bodyweight':modality}
                  setModality={m=>{ if(m==='hiit')return; setModality(m); const cur=ensurePinnedFor(m); setSession(cur); }}
                  lastModalityVisual={getLatestMainModalityFromHistory() || lsGet("last_modality", null) || null}
                  enabled={enabled}
                />
              </div>
            </div>

            <div className="flex gap-2">
              <button onClick={openWarmup} className="btn bg-emerald-700 w-full">Warm-up</button>
              <button
  onClick={() => {
    window.dispatchEvent(new Event('everstrong:start-inferno'));
  }}
  className="btn bg-indigo-600 w-full"
>
  Start Inferno (400 SU)
</button>

            </div>
            <div>
              <button onClick={restartSelected} className="btn bg-amber-600 w-full">Restart Current Modality</button>
            </div>
          </div>
        </CalmCard>
      );

      function pageByTab(id){
        if(id==='train') return PageTrain;
        if(id==='recovery') return PageRecovery;
        if(id==='history') return PageHistory;
        if(id==='export') return PageExport;
        if(id==='settings') return PageSettings;
        return PageTrain;
      }

      if (recoveryMode==="gate" && route==="gate") {
        return (
          <div className="mx-auto w-full max-w-md md:max-w-2xl min-h-screen flex items-start pt-4">
            <div className="w-full px-4">
              <div className="text-center mb-3">
                <h1 className="text-3xl font-bold">EverStrong</h1>
                <p className="text-gray-500 dark:text-gray-400 text-sm">Daily Recovery Check</p>
              </div>
              <div className="border border-black/10 dark:border-white/10 rounded-xl p-4 mb-4">
                <p className="font-semibold mb-2">Daily Recovery Check</p>

                <ScoreSelector label="Sleep Quality" keyName="sleep" value={sleepScore} onChange={setSleepScore}/>
                <ScoreSelector label="Energy" keyName="energy" value={energyScore} onChange={setEnergyScore}/>
                <ScoreSelector label="Body Readiness" keyName="body" value={bodyScore} onChange={setBodyScore}/>

                <p className="text-sm mt-1">Total: {totalRecovery||0} → <strong>{gateDecision.toUpperCase()}</strong></p>

                <div className="flex flex-col md:flex-row gap-2 mt-3">
<button
  className="btn bg-blue-600 w-full"
  onClick={()=>{
    lsSet("recovery:stamp", todayStr());
    lsSet("recovery:lastRoute", gateDecision);
    setRoute(gateDecision);

    // === Auto-pin mapping ===
    // 11–15 → train (niks pinnen)
    // 9–10  → Zone #2
    // 8     → DurabilitySequence
    // ≤7    → Breathing (10 min)
    if (gateDecision === "recovery") {
      let rec = null;
      if ((totalRecovery ?? 0) >= 9) {
        rec = chooseZone2Only();
      } else if ((totalRecovery ?? 0) === 8) {
        rec = chooseDurabilitySequence();
      } else {
        rec = buildBreathingSession(10, "Beginner");
      }
      const mod = rec.meta?.modality || "recovery";
      lsSet(`current:${mod}`, rec);
      setSession(rec);
      setActiveTab("recovery");
    } else if (gateDecision === "fullrest") {
      const b = buildBreathingSession(10, "Beginner");
      lsSet("current:breathing", b);
      setSession(b);
      setActiveTab("recovery");
    }
  }}
>
  Continue
</button>
                </div>
                <p className="text-xs text-gray-400 mt-2">We remember your choice until midnight.</p>
              </div>
              <p className="text-[11px] text-center text-gray-500 mt-3">You'll see training options after you confirm.</p>
            </div>
          </div>
        );
      }

      return (
        <AppShell
          activeTab={activeTab}
          setActiveTab={setActiveTab}
          onToggleDark={()=>document.documentElement.classList.toggle('dark')}
          calm={calm}
          setCalm={setCalm}
          recoveryMode={recoveryMode}
          setRecoveryMode={setRecoveryMode}
          recoveryCount={recoveryCount}
          REC_MAX={REC_MAX}
        >
          {pageByTab(activeTab)}
        </AppShell>
      );
    }

    /* ======= Modality Toggles / Performance ======= */
    function ModalityToggles({ modality, setModality, lastModalityVisual, enabled }) {
      const order = ["kettlebell","barbell","bodyweight"];
      const visible = order.filter(id => !enabled || enabled[id]);

      function Item({ id, label }){
        const active = (modality===id);
        const wasLast = (id===lastModalityVisual);
        let base = "px-3 py-2 rounded-lg cursor-pointer text-sm relative transition";
        let cls = base + " ";
        if (active && wasLast) {
          cls += "bg-blue-600 text-white ring-2 ring-red-400";
        } else if (active) {
          cls += "bg-blue-600 text-white";
        } else if (wasLast) {
          cls += "bg-gray-200 dark:bg-gray-800 ring-2 ring-red-400";
        } else {
          cls += "bg-gray-200 dark:bg-gray-800";
        }
        return (
          <label className={cls} title={wasLast ? "Last used" : ""}>
            <input type="radio" name="modality" className="hidden" checked={active} onChange={()=>setModality(id)} />
            {label}
            {wasLast && <span className="absolute -top-1 -right-1 w-2.5 h-2.5 bg-red-500 rounded-full" aria-hidden />}
          </label>
        );
      }

      if (visible.length===0) {
        return <div className="text-sm text-gray-500 dark:text-gray-400">No modalities enabled.</div>;
      }

      return (
        <div className="flex flex-wrap gap-2">
          {visible.includes("kettlebell") && <Item id="kettlebell" label="Kettlebell" />}
          {visible.includes("barbell") && <Item id="barbell" label="Barbell" />}
          {visible.includes("bodyweight") && <Item id="bodyweight" label="Bodyweight" />}
        </div>
      );
    }
function LastLoadTracker({ name, open }) {
  const last = getLastLoadFor(name);
  const [loadVal, setLoadVal] = React.useState(last?.load || "");
  const [rpeVal, setRpeVal] = React.useState(last?.rpe || "");

  // Als je de kaart openklapt, vul met laatste data
  React.useEffect(() => {
    if (open) {
      const fresh = getLastLoadFor(name);
      setLoadVal(fresh?.load || "");
      setRpeVal(fresh?.rpe || "");
    }
  }, [open, name]);

  return (
    <div className="mt-2 p-2 rounded-lg border border-black/10 dark:border-white/10">
      <div className="text-xs text-gray-500 dark:text-gray-400 mb-2">
        <span className="font-medium">Last set:</span>{" "}
        {last
          ? <>
              {last.load ? `${last.load}` : "—"}
              {last.rpe ? ` • RPE ${last.rpe}` : ""}
              {last.date ? ` • ${new Date(last.date).toLocaleDateString()}` : ""}
            </>
          : "No entry yet"}
      </div>

      <div className="grid grid-cols-1 sm:grid-cols-3 gap-2">
        <input
          className="w-full rounded px-2 py-1 bg-white dark:bg-gray-800 border border-black/10 dark:border-white/10"
          placeholder="Load (bv. 80 kg / 2x24 kg)"
          value={loadVal}
          onChange={(e)=>setLoadVal(e.target.value)}
        />
        <input
          className="w-full rounded px-2 py-1 bg-white dark:bg-gray-800 border border-black/10 dark:border-white/10"
          placeholder="RPE (1–10)"
          inputMode="numeric"
          value={rpeVal}
          onChange={(e)=>setRpeVal(e.target.value)}
        />
        <button
          className="btn-sm bg-gray-700"
          onClick={()=>{
            saveLastLoad(name, {
              load: loadVal.trim(),
              rpe: rpeVal.trim(),
              date: new Date().toISOString()
            });
            alert("Saved for " + name);
          }}
        >
          Save
        </button>
      </div>
    </div>
  );
}
    function PerformanceForm({ session, onChange }) {
  const m = session?.meta || {};
  const perf = m.performance || { load:"", rpe:"", notes:"" };
  const isStrength = ["kettlebell","barbell","bodyweight"].includes(m.modality);
  if(!isStrength) return null;

  return (
    <div>
      <div className="grid grid-cols-1 md:grid-cols-3 gap-2">
        <div>
          <label className="text-xs text-gray-400">Load</label>
          <input
            className="w-full px-2 py-1 rounded bg-gray-800"
            value={perf.load}
            onChange={e=>onChange({ ...perf, load:e.target.value })}
          />
        </div>
        <div>
          <label className="text-xs text-gray-400">RPE (1–10)</label>
          <input
            className="w-full px-2 py-1 rounded bg-gray-800"
            type="number" min="1" max="10"
            value={perf.rpe}
            onChange={e=>onChange({ ...perf, rpe:e.target.value })}
          />
        </div>
        <div className="md:col-span-3">
          <label className="text-xs text-gray-400">Notes</label>
          <textarea
            className="w-full px-2 py-1 rounded bg-gray-800" rows="3"
            value={perf.notes}
            onChange={e=>onChange({ ...perf, notes:e.target.value })}
          />
        </div>
      </div>
    </div>
  );
}
    ReactDOM.createRoot(document.getElementById('root')).render(<App/>);
  </script>
</body>
</html>

